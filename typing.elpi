% TODO:
% x fix case
% - fix not
% - test not, bot, top
% - separate files

% un programma Gamma è una lista di clausole
% una clausola è una formula della logica intuizionista di ordine superiore
% ristretta alla sintassi
%   P ::= Q => P | P :- Q | P,P | true | pi X \ P | exists x \ P
%       | p t1 ... tn | X t1 ... tn
%   Q ::= P => Q | Q :- P | Q,Q | Q;Q | true | false | pi x \ Q | exists X \ Q
%       | p t1 ... tn | X t1 .. tn

accumulate tlc_terms.
accumulate utils.

% ---- Typing rules for terms defined in tlc_terms ----

type of term -> typ -> o.
mode (of i o).
of (uvar as X) T :- declare_constraint (of X T) [X].
of (app Lam N) S :- of Lam (arr T S), of N T.
of (lam T Body) (arr T S) :- pi x \ of x T => of (Body x) S.

% product
of (pair Fst Snd) (prod T1 T2) :- of Fst T1, of Snd T2.
of (fst Pair) T :- of Pair (prod T S). 
of (snd Pair) S :- of Pair (prod T S). 

% sum
of (inl InL) (sum T1 T2) :- of InL T1.
of (inr InR) (sum T1 T2) :- of InR T2.
of (case M F G) T :-
    of M (sum T1 T2),
    (pi u \ of u T1 => of (F u) T), 
    (pi v \ of v T2 => of (G v) T). 

% ex falso
of singl unit.
of (abort T X) T :- of X void.
of (not T F) (arr T void) :-
    pi x \ of x T => of (F x) void.

%%%% TEST %%%%

% composizione aka \f: A -> B \g: B -> C \x: A . g f x
main :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    X = lam Z F,
    (pi x \
        F x = lam Z' (F' x),
        pi y \
            F' x y = lam Z'' (F'' x y),
            pi z \
                F'' x y z = app g (A x y z),
                A x y z = app x (B x y z),
                B x y z = z).


%%%% TACTICS %%%%

% return a lambda abstraction, prove (F x) 
tactic intro (lam Z F) Vars K :-
    pi x \ K [([x|Vars], (F x))].

% one step hypothetical app aka I don't have an immediate function
% ex: (A => B => C) => ((A & B) => C)
%     we'll need to do B => C, C |- C
tactic app (app H G) Vars K :-
    K [(Vars, G), (Vars, H)].

% one step concrete app aka I have a function that already proves the A => B part
tactic (app N) (app H G) Vars K :- 
    nth_element N Vars H, 
    K [(Vars, G)]. 

% and tactics
tactic andEL (fst X) Vars K :-
    K [(Vars, X)].
tactic andER (snd X) Vars K :-
    K [(Vars, X)].
tactic andI (pair A B) Vars K :-
    K [(Vars, A), (Vars, B)].

% or tactics
tactic orIL (inl T2 X) Vars K :-
    K [(Vars, X)].
tactic orIR (inr T1 X) Vars K :-
    K [(Vars, X)].
tactic orE (case M F G) Vars K :-
    pi u \ 
        pi v \
            K [(Vars, M), ([u|Vars], (F u)), ([v|Vars], (G v))].

% not 
% [A] ... \bot / -A
%tactic notI (not T F) Vars K :-
%    pi x \ K [([x|Vars]), (F x)].
% A -A / C
%tactic (notE N In) In Vars K :-
%    nth_element N Vars A,
%    K [(Vars, A), (Vars, (not T A))].
% \bot / C
%tactic botE (abort X T) Vars K :-
%    K [(Vars, X)].
% / \top
%tactic topI singl Vars K.

% hypothesis use
tactic (var N) H Vars K :- 
    nth_element N Vars H, 
    K [].


%%%% INTERACTIVE ENVIRONMENT %%%%

% interactive without script
interactive :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    loop [([],X)] [] [].

% interactive with script
interactive InScript :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    loop [([],X)] [] InScript.

% (A -> (B -> C)) -> ((A & B) -> C)
% TODO: I don't remember what tactic is tested
interactivea :-
    of X (arr (arr a (arr b c)) (arr (prod a b) c)),
    loop [([],X)] [] [].

intercativea InScript :-
    of X (arr (arr a (arr b c)) (arr (prod a b) c)),
    loop [([],X)] [] InScript.

% (A & B -> C) -> (A -> B -> C) 
% pairs test
% [intro, intro, intro, app, andI, var 2, var 1, var 3]
interactive_pairs :-
    of X (arr (arr (prod a b) c) (arr a (arr b c))),
    loop [([],X)] [] [].

interactive_pairs InScript :-
    of X (arr (arr (prod a b) c) (arr a (arr b c))),
    loop [([],X)] [] InScript.


% (A v B) -> (A -> C) -> (B -> C) -> C
% case test
% [intro, intro, intro, orE, var 3, app 3, var 1, app 2, var 1]
interactive_case :-
    of X (arr (sum a b) (arr (arr a c) (arr (arr b c) c))),
    loop [([],X)] [] [].

interactive_case InScript :-
    of X (arr (sum a b) (arr (arr a c) (arr (arr b c) c))),
    loop [([],X)] [] InScript.

% suml test
interactive_suml :-
    of X (arr a (sum a b)),
    loop [([],X)] [] [].
    
interactive_not :-
    of X (arr (pair a (arr a void)) c),
    loop [([],X)] [] [].
        

% ITP loop

% Idea: se non hai meta variabili da istanziare non fare nulla e stampa...
loop [] OutScript InScript :-
    reverse OutScript OutReversed,
    print "Total script:" OutReversed.

% Se hai metavariabili ma non hai uno script di input
loop [(Vars,X)|TL] OutScript [] :-
    print_constraints,
    print, print Vars "|-" X,
    read T,
    tactic T TE Vars (Goals \ sigma TL' \
        X = TE,
        append Goals TL TL',
        loop TL' [T|OutScript] []).

% Se hai metavariabili e hai uno script di input
loop [(Vars,X)|TL] OutScript [T|InScript] :-
    tactic T TE Vars (Goals \ sigma TL' \
        X = TE,
        append Goals TL TL',
        loop TL' [T|OutScript] InScript).
