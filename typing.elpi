% Il tipo dei tipi del lambda-calcolo tipato semplice
kind typ type.
type arr typ -> typ -> typ.     % t1 -> t2

%%%% MIE AGGIUNTE %%%%
type prod typ -> typ -> typ.    % t1 * t2
type sum typ -> typ -> typ.     % t1 + t2

% I termini del lambda-calcolo tipato semplice alla Church
% problema: posso avere unioni taggate con n elementi così come coppie di n elementi, come lo gestisco?
kind term type.
type var typ -> term.
type app term -> term -> term.
type lam typ -> (term -> term) -> term.

%%%% MIE AGGIUNTE %%%%
% product
type pair term -> term -> term.
type fst term -> term.
type snd term -> term.

% sum
% t1 -> t1 + t2
type inl typ -> term
% t2 -> t1 + t2
type inr typ -> term
% case m of 
% | Some x then x + 1
%   None   then 0
type case term -> term -> term -> term -> term

% esempio: lambda x:nat. x x
% diventa  lam nat (x \ app x x)


% un programma Gamma è una lista di clausole
% una clausola è una formula della logica intuizionista di ordine superiore
% ristretta alla sintassi
%   P ::= Q => P | P :- Q | P,P | true | pi X \ P | exists x \ P
%       | p t1 ... tn | X t1 ... tn
%   Q ::= P => Q | Q :- P | Q,Q | Q;Q | true | false | pi x \ Q | exists X \ Q
%       | p t1 ... tn | X t1 .. tn

%%%% REGOLE DI TIPAGGIO %%%%
type of term -> typ -> o.
mode (of i o).:w:w
of (uvar as X) B :- declare_constraint (of X B) [X].
of (var T V) T :- of V T.
of (app M N) B :- of M (arr A B), of N A.
of (lam A F) (arr A B) :- pi x \ of x A => of (F x) B.

% product
of (pair FST SND) (prod T1 T2) :- of FST T1, of SND T2.
of (fst P) A :- of P (prod A B). 
of (snd P) B :- of P (prod A B). 

% sum
of (inl T Left) (sum T S) :- of Left T.
of (inr S Right) (sum T S) :- of Right S.
of (case Sum Left X Right Y) T :- 
    of Sum (sum T1 T2), 
    (pi x \ of x T1 => of X T),
    (pi y \ of y T2 => of Y T). 
    


%%%% TEST %%%%

% composizione aka \f: A -> B \g: B -> C \x: A . g f x
main :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    X = lam Z F,
    (pi x \
        F x = lam Z' (F' x),
        pi y \
            F' x y = lam Z'' (F'' x y),
            pi z \
                F'' x y z = app g (A x y z),
                A x y z = app x (B x y z),
                B x y z = z).

% ???
main_pairs X :-
    of X (arr (prod nat nat) nat),
    X = lam T F,
    (pi x \
        F x = fst x).

main_union X :-
    of (case 
        (struct (const bool true) (const bool false)) 
        (const nat x)
        (const nat y))  X.

main_struct X :-
    of (struct (const bool true) (const nat x)) X.


%%%% UTILS %%%%

%length [] 0.
%length [_|TL] L :- length TL L', L is L' + 1.

% An element is nth if its the first of the nth sublist
nth_element 1 [X|_] X.
nth_element N [_|TL] X :- 
    M is N - 1,
    nth_element M TL X.


%%%% TACTICS %%%%

tactic intro (lam Z F) Vars K :- pi x \ K [([x|Vars],(F x))].
tactic (app N) (app H G) Vars K :- nth_element N Vars H, K [(Vars, G)]. 
tactic (var N) H Vars K :- nth_element N Vars H, K [].
%tactic (app 2) (app H G) Vars K :- Vars = [_,H|_], K [(Vars,G)].
%tactic (app 3) (app H G) Vars K :- Vars = [_,_,H|_], K [(Vars,G)].
%tactic (var 1) H Vars K :- Vars = [H|_], K [].


%%%% INTERACTIVE ENVIRONMENT %%%%

% interactive withouth script
interactive :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    OutScript = [],
    loop [([],X)] OutScript [].

% interactive with script
interactive InScript :-
    of X (arr (arr a b) (arr (arr b c) (arr a c))),
    OutScript = [],
    loop [([],X)] OutScript InScript.

% Non sono sicuro di aver fatto tutto giusto, anzi...
% Idea: se non hai meta variabili da istanziare non fare nulla e stampa...
loop [] OutScript InScript :-   % not so sure about this
    print "Total script:" OutScript.

% Se hai metavariabili ma non hai uno script di input
loop [(Vars,X)|TL] OutScript [] :-
    print OutScript,
    print_constraints,
    print, print Vars "⊢" X,
    read T,
    tactic T TE Vars (Goals \ sigma TL' \
        X = TE,
        append Goals TL TL',
        loop TL' [T|OutScript] []).

% Se hai metavariabili e hai uno script di input
loop [(Vars,X)|TL] OutScript [T|InScript] :-
    tactic T TE Vars (Goals \ sigma TL' \
        X = TE,
        append Goals TL TL',
        loop TL' [T|OutScript] InScript).

append [] L L.
append [X|XS] L [X|YS] :- append XS L YS.
