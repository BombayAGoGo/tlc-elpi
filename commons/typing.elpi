% ------------------------ %
% ---- TYPE INFERENCE ---- %
% ------------------------ %

type of term -> term -> term -> o.
mode (of i o o).
%of X T Y :- print (of X T Y), fail.
of (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X].

% ----------------------- %
% ---- TYPE CHECKING ---- %
% ----------------------- %

type isa term -> term -> term -> o.
mode (isa i o o).
%isa X T Y :- print (isa X T Y), fail.
isa (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X].

isa Te Ty OTe :-
    conv Ty Ty',
    of Te Ty' OTe.

constraint get_type isa get_ctx {
    rule (isa (uvar K _ as X) T _)
    \ (get_type (uvar K _ as Y) S)
    <=> (S = T).

    % NOTE: pretty big assumption i.e. that
    % constraints in Ctx have the same order
    % of the variables in L
    rule (Ctx ?- isa (uvar K _ as X) T O)
    \ (get_ctx (uvar K L as Y) Body)
    | (reverse Ctx RCtx, transfer_ctx RCtx L NCtx, reverse NCtx RNCtx)
    <=> (RNCtx ?- Body).
}

mode (transfer_ctx i i o).
%transfer_ctx A B C :- print (transfer_ctx A B C), fail.
transfer_ctx [] _ [].
transfer_ctx [(isa X T O)|CS] [Y|YS] [(isa Y T O)|OutCtx] :- transfer_ctx CS YS OutCtx.
