% TODO:
% - controllo degli errori piu' fine per project etc

% -------------- %
% ---- LOOP ---- %
% -------------- %

% itp_loops args:
% - list of current open goals
% - input tactics list
% - output script list
mode (itp_loop i i o).
%itp_loop A B C :- print (itp_loop A B C), fail.
itp_loop ([], [], [], _) _ [].

itp_loop State [] OutScript :-
    print_status State,
    prompt_user "input tactic" Tac,
    (Tac = backup, !, fail;
    process_tac Tac State NewState,
    itp_loop NewState [] OutScript',
    append [Tac] OutScript' OutScript;
    itp_loop State [] OutScript).

itp_loop State (Tac :: Tacs) OutScript :-
    process_tac Tac State NewState,
    itp_loop NewState Tacs OutScript',
    append [Tac] OutScript' OutScript.


% ------------------- %
% ---- INTERNALS ---- %
% ------------------- %

% key ideas:
% itp carries around a state which is representeted by a tuple of tre elements:
%   1. list of active goals,
%   2. list of inactive goals (which is a list of lists, because of nesting)
%   3. list of nesting levels L ::= b :: L | f :: L | []
% branch and focus put b and f on top of Levels then:
%   - select some goals
%   - add the remaining goals as an inactive list
% when they close:
%   - remove b/f from Levels
%   - restore the current list on top of the inactive list


% ---- BRANCHING ---- %

mode (process_tac i i o).
%process_tac A B C :- print (process_tac A B C), fail.
% branch lables branch context goals but they are only needed for projection,
% so we can keep numbering goals from max goal number
process_tac branch
    (Goal :: Goals, Inactive, Levels, Mgn)
    ([Goal], (BranchCtx, [], BranchCtx) :: Inactive, b :: Levels, Mgn) :-
    label_branch_ctx (Goal :: Goals) BranchCtx.

% shift when goal isn't processed
process_tac shift
    ([OldHd], (OldHd :: (N, NewHd) :: Rest, CtxCpy) :: Inactive, b :: Levels, Mgn)
    ([NewHd], ((N, NewHd) :: Rest, BranchOut, CtxCpy) :: Inactive, b :: Levels, Mgn).

% shift when goal is processed
process_tac shift
    (Active, (OldHd :: (N, NewHd) :: Rest, BranchOut, CtxCpy) :: Inactive, b :: Levels, Mgn)
    ([NewHd], ((N, NewHd) :: Rest, NewOut, CtxCpy) :: Inactive, b :: Levels, Mgn) :-
    append BranchOut Active NewOut.

% unbranch when goal isn't processed
process_tac unbranch
    (CurrentCtx, (CurrentCtx :: _Ctxs, BranchOut, CtxCpy) :: Inactive, b :: Levels, Mgn)
    (NewActive, Inactive, Levels, Mgn) :-
    get_unclosed_goals CtxCpy Unclosed,
    append Unclosed BranchOut NewActive.

% unbranch when goal is processed
process_tac unbranch
    (Active, (_Ctx, BranchOut, CtxCpy) :: Inactive, b :: Levels, Mgn)
    (NewActive, Inactive, Levels, Mgn) :-
    get_unclosed_goals CtxCpy Unclosed,
    append Unclosed BranchOut Tmp,
    append Tmp Active NewActive.


% can apply project only right after branch open or shift i.e. when the head of
% the branch context is also the only active goal
process_tac (project []) State State.
process_tac (project Ns)
    ([Hd], ((M, Hd) :: Ctx, BranchOut) :: Inactive, b :: Levels, Mgn)
    (Selected, (Rest, BranchOut) :: Inactive, b :: Levels, Mgn) :-
    all_sequential Ns,
    get_numbered_goals Ns ((M, Hd) :: Ctx) Selected Rest.

% NOTE: after a project all we don't care about the branch context becuase no
%       more shifts or projections can be done, only unbranch.
process_tac (project all)
    ([Hd], ((M, Hd) :: Ctx, BranchOut) :: Inactive, b :: Levels, Mgn)
    (Unlabled, ([], BranchOut) :: Inactive, b :: Levels, Mgn) :-
    unlabel_branch_ctx ((M, Hd) :: Ctx) Unlabled.

% error reporting
process_tac shift
    ((Active, ([Single], BranchOut) :: Inactive, Levels, Mgn) as State)
    State :-
    print "error: shift cannot be performed on a single goal context".
process_tac shift ((Active, Inactive, [], Mgn) as State) State :-
    print "error: can't shift outside of a branch".
process_tac shift ((Active, Inactive, f :: Levels, Mgn) as State) State :-
    print "error: can't shift inside a focus".

process_tac unbranch ((Active, Inactive, [], Mgn) as State) State :-
    print "error: no branch to close".
process_tac unbranch ((Active, Inactive, (f :: Levels), Mgn) as State) State :-
    print "error: focus must be closed with unfocus".

% if you are here Ns is not empty but Active and Inactive are not in a
% projectable form i.e. [Hd] ((M, Hd) :: Rest) 
process_tac (project P) ((Active, Inactive, b :: Levels, Mgn) as State) State :-
    print "error: can't project in a developed branch".
process_tac (project P) ((Active, Inactive, []) as State) State :-
    print "error: can't project outside of a branch".
process_tac (project P) ((Active, Inactive, f :: Levels, Mgn) as State) State :-
    print "error: can't project in a focus".


% ---- FOCUS ---- %

process_tac (focus []) State State.
process_tac (focus GoalIdxs) (Active, Inactive, Levels, Mgn) (NewActive, (Rest :: Inactive), (f :: Levels), Mgn) :-
    get_numbered_goals GoalIdxs Active NewActive Rest.
    %append [Rest] Inactive NewInactive.
process_tac unfocus ([], (I :: Inactive), (f :: Levels), Mgn) (I, Inactive, Levels, Mgn).
% error reporting

process_tac unfocus ((NonEmptyGoals, Inactive, Levels, Mgn) as State) State :-
    print "error: you ain't done".
process_tac unfocus ((Goals, Inactive, []) as State) State :-
    print "error: no focus to close".
process_tac unfocus ((Goals, Inactive, (b :: Levels), Mgn) as State) State :-
    print "error: branch must be closed with unbranch".
    

% ---- MAPTAC ---- %

process_tac (maptac _ []) State State.
process_tac (maptac Tac GoalIdxs) (Active, Inactive, Levels, Mgn) (NActive, Inactive, Levels, NMgn) :-
    get_numbered_goals GoalIdxs Active Selected Rest,
    tactic maptac Tac Selected UGoals,
    label_goals Mgn UGoals NMgn LGoals,
    append LGoals Rest NActive.


% ---- THEN ---- %

process_tac (then T1 T2) State NewState :-
    process_tac T1 State MidState, process_tac T2 MidState NewState.


% ---- DEFAULT ---- %

% default: Tac is applied to the first goal
process_tac Tac (((N, Goal) :: Active), Inactive, Levels, Mgn) (NewActive, Inactive, Levels, NMgn) :-
    exec_tac Tac Goal UGoals,
    label_goals Mgn UGoals NMgn LGoals,
    append LGoals Active NewActive.


/*
%   Execute tactic under context of a goal
*/
mode (exec_tac i i o).
exec_tac A B C :- print (exec_tac A B C), fail.
exec_tac Tac (goal X T Y V as Goal) NewGoals :- exec_tac_aux Tac Goal V [] NewGoals.

mode (exec_tac_aux i i i i o).
exec_tac_aux Tac (goal X T Y D) (vdecl N _ :: VDecls) FVars NG :-
    pi x\ exec_tac_aux Tac (goal (X x) T (Y x) D) VDecls ((x, N) :: FVars) NG.
exec_tac_aux Tac (goal X T Y D as G) [] FVars NewGoals :-
    tactic Tac G FVars NewGoals.

mode (build_newgoals i i o).
%build_newgoals A B C :- print (build_newgoals A B C), fail.
build_newgoals (uvar K L as Y) VDecls NewGoals :-
    lookdown Y X T,
    NewGoals = [goal X T K VDecls].
build_newgoals (lam N T F) VDecls NewGoals :-
    append VDecls [vdecl N T] L,
    pi x\ build_newgoals (F x) L NewGoals.
build_newgoals (app M N) VDecls NewGoals :-
    build_newgoals M VDecls NewGoals',
    build_newgoals N VDecls NewGoals'',
    append NewGoals' NewGoals'' NewGoals.
build_newgoals (pair M N) VDecls NewGoals :-
    build_newgoals M VDecls NewGoals',
    build_newgoals N VDecls NewGoals'',
    append NewGoals' NewGoals'' NewGoals.
build_newgoals FVar _ [] :- name FVar.


% ------------------------ %
% ---- BRANCH HELPERS ---- %
% ------------------------ %

mode (label_branch_ctx_aux i i i o).
label_branch_ctx_aux M N [] [] :- M is N.
label_branch_ctx_aux M N (Goal :: Goals) ((SM, Goal) :: LGoals) :-
    SM is M + 1, label_branch_ctx_aux SM N Goals LGoals.

mode (label_branch_ctx i o).
label_branch_ctx Goals LGoals :-
    length Goals N,
    label_branch_ctx_aux 0 N Goals LGoals.

mode (unlabel_branch_ctx i o).
unlabel_branch_ctx [] [].
unlabel_branch_ctx ((_L, LGoal) :: LGoals) (LGoal :: Goals) :-
    unlabel_branch_ctx LGoals Goals.

mode (all_sequential i).
all_sequential (N :: N' :: Ns) :-
    N' is N + 1, all_sequential (N' :: Ns).

mode (get_unclosed_goals i o).
get_unclosed_goals [] [].
get_unclosed_goals ((_N, Goal) :: Ctxs) (Goal :: UCtxs) :-
    not (closed_goal Goal),
    get_unclosed_goals Ctxs UCtxs.
get_unclosed_goals (Ctx :: Ctxs) UCtxs :-
    get_unclosed_goals Ctxs UCtxs.

mode (closed_goal i).
closed_goal (goal (uvar as X) _T _Y _V) :- !, fail.
closed_goal G.


% ------------------------- %
% ---- TACTICS HELPERS ---- %
% ------------------------- %

% get N goals from goal list
%mode (get_goals i i o o).
%get_goals A B C D :- print (get_goals A B C D), fail.
%get_goals [] Rest [] Rest.
%get_goals (N :: GoalsToPick) Goals OutGoals Rest :-
%    get_nth N Goals Left Right Goal,
%    append Left Right Rest',
%    dec_greater N GoalsToPick GoalsToPickFixed,
%    get_goals GoalsToPickFixed Rest' OutGoals' Rest,
%    append [Goal] OutGoals' OutGoals.

mode (get_numbered_goals_aux i i o o o).
%get_numbered_goal_aux A B C D E :- print (get_numbered_goal_aux A B C D E), fail.
get_numbered_goal_aux N [] [] nil [] :- fail.
    %ErrMsg is "get_numbered_goal_aux error: " ^ N ^ " is not in goal list",
    %print ErrMsg.
get_numbered_goal_aux N ((M, NGoal) :: NGoals) [] NGoal NGoals :- N is M.
get_numbered_goal_aux N ((M, NGoal) :: NGoals) ((M, NGoal) :: Left) Selected Right :-
    not (N is M),
    get_numbered_goal_aux N NGoals Left Selected Right.

mode (get_numbered_goals i i o o).
%get_numbered_goals A B C D :- print (get_numbered_goals A B C D), fail.
get_numbered_goals [] NGoals [] NGoals.
get_numbered_goals (N :: Ns) NGoals (S :: Selected) Rest :-
    get_numbered_goal_aux N NGoals Left S Right,
    append Left Right NGoals',
    get_numbered_goals Ns NGoals' Selected Rest.

mode (label_goals i i o o).
%label_goals A B C D :- print (label_goals A B C D), fail.
label_goals Mgn [] Mgn [].
label_goals Mgn (Goal :: Goals) NMgn ((Mgn', Goal) :: LGoals) :-
    Mgn' is Mgn + 1,
    label_goals Mgn' Goals NMgn LGoals.

mode (get_nth i i o o o).
%get_nth A B C D E :- print (get_nth A B C D E), fail.
get_nth 1 [X|XS] [] XS X.
get_nth N [X|XS] L R Res :-
    M is N - 1,
    get_nth M XS L' R Res,
    append [X] L' L.     

dec_greater _ [] [].
dec_greater N (M :: MS) (M' :: MS') :-
    (M > N, M' is M - 1; M' = M),
    dec_greater N MS MS'.


% ----------------------- %
% ---- META RECOVERY ---- %
% ----------------------- %

mode (lookdown i i i).
lookdown (uvar _ _ as X) Y T :- declare_constraint (read-refined X Y T) [X].

constraint isa read-evar read-refined of {
     rule (E1 : Ctx ?- isa (uvar K L1) Ty (uvar O L1' as Y))
        \ (E2 : read-refined (uvar O L2) X T)
        | (/* print "match" L1 L1' L2, */ L1 = L1', !; print "align fail on" L1 "=" L1', halt)
        <=> (E2 : X = uvar K [], T = Ty).
}
