% TODO:
% - controllo degli errori piu' fine per project etc
% - refactoring
% - riscrivi funzionamento branching e focus
% - suddivisone migliore codice

% -------------- %
% ---- LOOP ---- %
% -------------- %

% itp_loops args:
% - state (current open goals, inactive list, levels, max goal number)
% - input tactics list
% - remaining goals
% - output script list
mode (itp_loop i i o o).
%itp_loop A B C :- print (itp_loop A B C), fail.
itp_loop State _ [] [] :- empty_state State.

itp_loop State [] OutGoals OutScript :-
    print_status State,
    prompt_user "input tactic" Tac,
    (Tac = backup, !, fail;
    Tac = quit, get_outgoals State OutGoals, !;
    process_tac Tac State NewState,
    itp_loop NewState [] OutGoals OutScript',
    append [Tac] OutScript' OutScript;
    itp_loop State [] OutGoals OutScript).

itp_loop State [Tac|Tacs] OutGoals OutScript :-
    process_tac Tac State NewState,
    itp_loop NewState Tacs OutGoals OutScript',
    append [Tac] OutScript' OutScript.


empty_state (state [] [] [] _).
get_outgoals (state OG _ _ _) OG' :- unlabel_goals OG OG'.

% ------------------- %
% ---- INTERNALS ---- %
% ------------------- %

% key ideas:
% itp carries around a state which is representeted by a tuple of tre elements:
%   1. list of active goals,
%   2. list of inactive goals (which is a list of lists, because of nesting)
%   3. list of nesting levels L ::= b :: L | f :: L | []
% branch and focus put b and f on top of Levels then:
%   - select some goals
%   - add the remaining goals as an inactive list
% when they close:
%   - remove b/f from Levels
%   - restore the current list on top of the inactive list


% ---- BRANCHING ---- %

mode (process_tac i i o).

% skip_goal blocks the user until he/she acknowledges with skip
process_tac T ((state [(0, skip_goal)] I L M) as S) S :- print "you have to skip".

%process_tac A B C :- print (process_tac A B C), fail.
% branch lables branch context goals but they are only needed for projection,
% so we can keep numbering goals from max goal number
process_tac branch
    (state [Goal|Goals] I Levels M)
    (state [Goal] [bctx BranchCtx [] BranchCtx|I] [b|Levels] M) :-
    label_branch_ctx [Goal|Goals] BranchCtx.

process_tac shift
    (state Active [bctx [_, (N, (goal X T Y V) as NewHd)|R] BranchOut C|I] [b|L] M)
    (state NewActive [bctx [(N, NewHd)|R] NewOut C|I] [b|L] M) :-
    closed_goal NewHd, build_newgoals NewHd V NewGoals,
    (NewGoals = [], NewActive = [(0, skip_goal)], !;
    NewActive = NewGoals),
    append BranchOut Active NewOut.
process_tac shift
    (state Active [bctx [_, (N, NewHd)|R] BranchOut C|I] [b|L] M)
    (state [NewHd] [bctx [(N, NewHd)|R] NewOut C|I] [b|L] M) :-
    append BranchOut Active NewOut.

% unbranch can't close a branch without skipping first
process_tac unbranch
    (state Active [bctx _ BranchOut CtxCpy|I] [b|Levels] M)
    (state NewActive I Levels M) :-
    get_unclosed_goals CtxCpy Unclosed,
    append BranchOut Active DirtyActive,
    remove_unclosed Unclosed DirtyActive CleanActive,
    append Unclosed CleanActive NewActive.

% can apply project only right after branch open or shift i.e. when the head of
% the branch context is also the only active goal
process_tac (project []) State State.
process_tac (project [Idx|Idxs])
    (state [Hd] [bctx [(Idx, Hd)|Ctx] BranchOut CtxCpy|I] [b|L] M)
    (state Selected [bctx [(Pos, Tail)|Rest] BranchOut CtxCpy|I] [b|L] M) :-
    all_sequential [Idx|Idxs],
    get_numbered_goals [Idx|Idxs] [(Idx, Hd)|Ctx] Selected Rest,
    append _ [Tail] Selected,
    get_pos_in_ctx Tail CtxCpy Pos.

% NOTE: after a project all we don't care about the branch context becuase no
%       more shifts or projections can be done, only unbranch.
process_tac (project all)
    (state [Hd] [bctx [(Id, Hd)|Ctx] BranchOut CtxCpy|I] [b|L] M)
    (state Unlabled [bctx [Tail] BranchOut CtxCpy|I] [b|L] M) :-
    unlabel_branch_ctx [(Id, Hd)|Ctx] Unlabled,
    append _ [Tail] CtxCpy.

% error reporting
process_tac shift
    ((state A [bctx [S] B C|I] L M) as State) State :-
    print "error: shift cannot be performed on a single goal context".
process_tac shift ((state A I [] M) as State) State :-
    print "error: can't shift outside of a branch".
process_tac shift ((state A I [f|L] M) as State) State :-
    print "error: can't shift inside a focus".

process_tac skip ((state A I [b|L] M) as S) S:-
    print "error: can't skip".
process_tac skip ((state A I [f|L] M) as S) S :-
    print "error: can't skip inside a focus".
process_tac skip ((state A I [] M) as S) S :-
    print "error: can't skip outside of a branch".

process_tac unbranch ((state A I [] M) as State) State :-
    print "error: no branch to close".
process_tac unbranch ((state A I [f|L] M) as State) State :-
    print "error: focus must be closed with unfocus".

% if you are here Ns is not empty but Active and Inactive are not in a
% projectable form i.e. [Hd] [(M, Hd)|Rest] 
process_tac (project [Id|Idxs])
    ((state [Hd] [bctx [(N, Hd)|Ct] B Cp|I] [b|L] M) as State) State :-
    term_to_string Id SId, term_to_string N SN,
    ErrMsg is "error: can't project from index " ^ SId ^ " (min index: " ^ SN ^ ")", 
    print ErrMsg.
process_tac (project P) ((state A I [b|L] M) as State) State :-
    print "error: can't project in a developed branch".
process_tac (project P) ((state A I [] M) as State) State :-
    print "error: can't project outside of a branch".
process_tac (project P) ((state A I [f|L] M) as State) State :-
    print "error: can't project in a focus".


% ---- FOCUS ---- %

process_tac (focus []) S S.
process_tac (focus GoalIdxs) (state Active I Levels M) (state NewActive [Rest|I] [f|Levels] M) :-
    get_numbered_goals GoalIdxs Active Selected Rest,
    add_labels GoalIdxs Selected NewActive.
process_tac unfocus (state [] [I|Inactive] [f|Levels] M) (state I Inactive Levels M).

% error reporting
process_tac unfocus ((state A I L M) as State) State :-
    print "error: you ain't done".
process_tac unfocus ((state A I [] M) as State) State :-
    print "error: no focus to close".
process_tac unfocus ((state A I [b|Levels] M) as State) State :-
    print "error: branch must be closed with unbranch".
    
% ---- MAPTAC ---- %

process_tac (maptac _ []) S S.
process_tac (maptac Tac GoalIdxs) (state Active I L Mgn) (state NActive I L NMgn) :-
    get_numbered_goals GoalIdxs Active Selected Rest,
    tactic maptac Tac Selected UGoals,
    label_goals Mgn UGoals NMgn LGoals,
    append LGoals Rest NActive.


% ---- THEN ---- %

process_tac (then T1 T2) State NewState :-
    process_tac T1 State MidState, process_tac T2 MidState NewState.


% ---- DEFAULT ---- %

% default: Tac is applied to the first goal
process_tac Tac (state [(N, Goal)|Active] I L Mgn) (state NewActive I L NMgn) :-
    exec_tac Tac Goal UGoals,
    label_goals Mgn UGoals NMgn LGoals,
    append LGoals Active NewActive.


/*
%   Execute tactic under context of a goal
*/
mode (exec_tac i i o).
exec_tac Tac (goal X T Y V as Goal) NewGoals :- exec_tac_aux Tac Goal V [] NewGoals.

mode (exec_tac_aux i i i i o).
exec_tac_aux Tac (goal X T Y D) [vdecl N TN|VDecls] FVars NG :-
    pi x\ of x TN x => exec_tac_aux Tac (goal (X x) T (Y x) D) VDecls [(x, N)|FVars] NG.
exec_tac_aux Tac (goal X T Y D as G) [] FVars NewGoals :-
    tactic Tac G FVars NewGoals.


% ------------------------ %
% ---- BRANCH HELPERS ---- %
% ------------------------ %

mode (label_branch_ctx_aux i i i o).
label_branch_ctx_aux M N [] [] :- M is N.
label_branch_ctx_aux M N [Goal|Goals] [(SM, Goal)|LGoals] :-
    SM is M + 1, label_branch_ctx_aux SM N Goals LGoals.

mode (label_branch_ctx i o).
label_branch_ctx Goals LGoals :-
    length Goals N,
    label_branch_ctx_aux 0 N Goals LGoals.

mode (unlabel_branch_ctx i o).
unlabel_branch_ctx [] [].
unlabel_branch_ctx [(_L, LGoal)|LGoals] [LGoal|Goals] :-
    unlabel_branch_ctx LGoals Goals.

all_sequential [_].
all_sequential [N, N'|Ns] :-
    N' is N + 1, all_sequential [N'|Ns].

mode (get_unclosed_goals i o).
get_unclosed_goals [] [].
get_unclosed_goals [(_N, Goal)|Ctxs] [Goal|UCtxs] :-
    not (closed_goal Goal),
    get_unclosed_goals Ctxs UCtxs.
get_unclosed_goals [Ctx|Ctxs] UCtxs :-
    get_unclosed_goals Ctxs UCtxs.

mode (closed_goal i).
closed_goal (_N, goal (uvar as X) _T _Y _V) :- !, fail.
closed_goal G.

mode (remove_unclosed_aux i i o).
remove_unclosed_aux N [] [].
remove_unclosed_aux N [(M, Goal)|Goals] Goals :- N is M. 
remove_unclosed_aux N [(M, Goal)|Goals] [(M, Goal)|Removed] :-
    not (N is M), remove_unclosed_aux N Goals Removed. 

mode (remove_unclosed i i o).
remove_unclosed [] Removed Removed.
remove_unclosed [(N, _)|Unclosed] Goals Removed :-
    remove_unclosed_aux N Goals Goals',
    remove_unclosed Unclosed Goals' Removed.

mode (get_pos_in_ctx i i o).
get_pos_in_ctx (N, _) [] 0 :- print "error(get_pos_in_ctx): " N " not in ctx".
get_pos_in_ctx (N, _) [(M, (O, _))|_] M :- N is O.
get_pos_in_ctx (N, _) [(_, (O, _))|Ctx] M :- not (N is O), get_pos_in_ctx (N, _) Ctx M.

% ------------------------- %
% ---- TACTICS HELPERS ---- %
% ------------------------- %

mode (get_numbered_goals_aux i i o o o).
%get_numbered_goal_aux A B C D E :- print (get_numbered_goal_aux A B C D E), fail.
get_numbered_goal_aux N [] [] nil [] :- print "Goal" N "not in list", fail.
get_numbered_goal_aux N [(M, NGoal)|NGoals] [] NGoal NGoals :- N is M.
get_numbered_goal_aux N [(M, NGoal)|NGoals] [(M, NGoal)|Left] Selected Right :-
    not (N is M),
    get_numbered_goal_aux N NGoals Left Selected Right.

mode (get_numbered_goals i i o o).
%get_numbered_goals A B C D :- print (get_numbered_goals A B C D), fail.
get_numbered_goals [] NGoals [] NGoals.
get_numbered_goals [N|Ns] NGoals [S|Selected] Rest :-
    get_numbered_goal_aux N NGoals Left S Right,
    append Left Right NGoals',
    get_numbered_goals Ns NGoals' Selected Rest.

mode (label_goals i i o o).
%label_goals A B C D :- print (label_goals A B C D), fail.
label_goals Mgn [] Mgn [].
label_goals Mgn [Goal|Goals] NMgn [(Mgn', Goal)|LGoals] :-
    Mgn' is Mgn + 1,
    label_goals Mgn' Goals NMgn LGoals.

mode (unlabel_goals i o).
unlabel_goals [] [].
unlabel_goals [(_, G)|Gs] [G|UGs] :- unlabel_goals Gs UGs.

mode (get_nth i i o o o).
%get_nth A B C D E :- print (get_nth A B C D E), fail.
get_nth 1 [X|XS] [] XS X.
get_nth N [X|XS] L R Res :-
    M is N - 1,
    get_nth M XS L' R Res,
    append [X] L' L.     

dec_greater _ [] [].
dec_greater N [M|MS] [M'|MS'] :-
    (M > N, M' is M - 1; M' = M),
    dec_greater N MS MS'.


% ---- FOCUS HELPERS ---- %

mode (add_labels i i o).
add_labels [] [] [].
add_labels [L|Ls] [Goal|Goals] [(L, Goal)|LGoals] :- add_labels Ls Goals LGoals.

% ----------------------- %
% ---- META RECOVERY ---- %
% ----------------------- %

mode (lookdown i i i).
lookdown (uvar _ _ as X) Y T :- declare_constraint (read-refined X Y T) [X].

constraint isa read-evar read-refined of {
     rule (E1 : Ctx ?- isa (uvar K L1) Ty (uvar O L1' as Y))
        \ (E2 : read-refined (uvar O L2) X T)
        | (print "align-debug: " K L1 "-" O L1' "-" O L2, L1 = L1', !; print "align fail on" L1 "=" L1', halt)
        <=> (E2 : X = uvar K [], T = Ty).
}
