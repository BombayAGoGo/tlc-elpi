% ------------------------ %
% ---- CONV EXTENSION ---- %
% ------------------------ %

% INVARIANT: here we only deal with terms without names since conversion takes
%            them out before arriving here

% TODO:
% v is_stuck deve considerare anche forall_app e impl_app
% v conv_constraint sulle altre app
% v is_closed sui termini mtt
% v stop reductions per i termini che calcolano
% v riduzione controllata per tutti i termini che calcolano
% v mimica tipi
% v unwind con applicazioni eterogenee
% v lambda per applicazioni eterogenee
% - use_var per i termini su cui ha senso
% - mimica per i termini

mode (is_stuck i).
is_stuck uvar.
is_stuck (app M _) :- is_stuck M.
is_stuck (forall_app M _) :- is_stuck M.
is_stuck (impl_app M _) :- is_stuck M.
%is_stuck _ :- fail.

mode (conv i i).
conv X Y :- print (conv X Y), fail.
conv X Y :- is_stuck X, is_stuck Y, !, conv_constraint X Y X Y.
conv X Y :- (is_stuck X, !; is_stuck Y), !,
    unwind_app X XApp XArgs , unwind_app Y YApp YArgs,
    unify XApp XArgs YApp YArgs.
% If X or Y isn't stuck then it will become a `multi_app X/Y []` and later the
% multi_app will be removed.

% Get the uvars that made A and B stuck and put a conversion constraint on them
mode (conv_constraint i i).
conv_constraint (app M _) S A B :- conv_constraint M S A B.
conv_constraint T (app M _) A B :- conv_constraint T M A B. 
conv_constraint (forall_app M _) S A B :- conv_constraint M S A B.
conv_constraint T (forall_app M _) A B :- conv_constraint T M A B. 
conv_constraint (impl_app M _) S A B :- conv_constraint M S A B.
conv_constraint T (impl_app M _) A B :- conv_constraint T M A B. 
conv_constraint (uvar as X) (uvar as Y) A B :- !, declare_constraint (conv A B) [X, Y].

accumulate catch_redexes.

% --------------------- %
% ---- UNIFICATION ---- %
% --------------------- %

macro @unify T S :- unify T [] S [].

mode (unify i i i i).
unify A B C D :- print (unify A B C D), fail.

% delay flex-flex
unify (uvar as X) [] (uvar as Y) [] :- !,
    declare_constraint (unify X [] Y []) [X, Y].

accumulate unify_redexes.

% unwind app
mode (unwind_app i o o).
unwind_app X Out Args :-
    unwind_app_aux X [] [] Out.

mode (unwind_app_aux i i i o).
unwind_app_aux (uvar as X) AppTypes [] (multi_app X AppTypes).
unwind_app_aux (app X Y) AppType Args Out :- !,
    append Args' [Y] Args,
    append [setPiApp] AppTypes AppTypes',
    unwind_app X AppType' Args' Out.
unwind_app_aux (forall_app X Y) AppTypes Args Out :- !,
    append Args' [Y] Args,
    append [forallApp] AppTypes AppTypes',
    unwind_app X Args' AppType'.
unwind_app_aux (impl_app X Y) AppTypes Args Out :- !,
    append Args' [Y] Args,
    append [implApp] AppTypes AppTypes',
    unwind_app X Args' AppType'.

mode (rewind_app i i o).
rewind_app (multi_app X AppTypes) Args Out :-
    rewind_app_aux X AppTypes Args Out. 
mode (rewind_app_aux i i i o).
rewind_app_aux App [] [] App.
rewind_app_aux App [setPiApp|ATs] [L|Ls] Out :-
    rewind_app_aux (app App L) ATs Ls Out.
rewind_app_aux App [forallApp|ATs] [L|Ls] Out :-
    rewind_app_aux (forall_app App L) ATs Ls Out.
rewind_app_aux App [implApp|ATs] [L|Ls] Out :-
    rewind_app_aux (impl_app App L) ATs Ls Out.

% Meta with args is a lambda/forall_lam/impl_lam
unify (multi_app (uvar as X) [setPiApp|ATs]) [L|Ls] T L' :- !, 
    print "lam" X L T L',
    of L LTy _ _, X = lambda LTy F,
    pi x\ (locDecl x LTy, copy x L) => unify (F x) Ls T L'.

unify (multi_app (uvar as X) [forallApp|ATs]) [L|Ls] T L' :- !, 
    print "flam" X L T L',
    of L LTy _ _, X = forall_lam LTy F,
    pi x\ (locDecl x LTy, copy x L) => unify (F x) Ls T L'.

unify (multi_app (uvar as X) [implApp|ATs]) [L|Ls] T L' :- !, 
    print "ilam" X L T L',
    of L LTy _ _, X = impl_lam LTy F,
    pi x\ (locDecl x LTy, copy x L) => unify (F x) Ls T L'.

% Erase multi_app for non applied metas
unify (multi_app (uvar as X) []) [] T L' :- !, unify X [] T L'.

% ---- TYPE UNIFICATION ---- %

accumulate type_mimic.

% ---- TERM UNIFICATION ---- %

% PROJECTION
unify (uvar _ Vs as X) [] Term Arg :- print "proj" X Term Arg, rewind_app Term Arg App, try_projection X Vs App.

mode (try_projection i i i).
try_projection _ [] _ :- fail.
try_projection X [V|Vs] App :-
    (not (forbid V), get_copy V T', use_var V T' App Asgn, X = Asgn);
    try_projection X Vs App.

mode (get_copy i o).
get_copy V X :- declare_constraint (copy V X) [X].

mode (use_var i i i o).
use_var A B C D :- print (use_var A B C D), fail.
use_var V (pair A _) S O :- use_var (fst V) A S O.
use_var V (pair _ B) S O :- use_var (snd V) B S O.
use_var V (pair A B) S O :-
    of (pair A B) (sum T S) _,
    pi x y\ (of x T x, of y (S x) y, copy x A, copy y B, forbid V) => use_var (split V F) (F x y) S O.
%use_var V (succ N) S O :-
%    of (natrec N ZE RF) A _,
%    pi x y\ (of x nat x, of y (A x) y, copy x (succ N), copy y (natrec N ZE RF), forbid V) => use_var (natrec V ZE RF) (RF x y) S O.
use_var V T S V :- conv T S.

% MIMIC

accumulate term_mimic.

% Prod
unify (uvar as X) [] T [A|As] :-
    print "app" X T [A|As],
    X = app M N,
    append Body [Tail] [A|As],
    unify M [] T Body,
    unify N [] Tail [].
unify (uvar as X) [] (lam T F) [] :-
    print "lam",
    X = lam T G, pi x\ of x T x => unify (G x) [] (F x) [].

% Sum
unify (uvar as X) [] (pair M N) [] :- !,
    print "pair",
    X = pair P Q, unify P [] M [], unify Q [] N [].
unify (uvar as X) [] (fst P) [] :- !,
    print "fst",
    X = fst Q, unify Q [] P [].
unify (uvar as X) [] (snd P) [] :- !,
    print "snd",
    X = snd Q, unify Q [] P [].
unify (uvar as X) [] (split P F) [] :- !,
    of P (sum A _) _,
    X = split Q G,
    unify Q [] P [],
    pi x\ of x A x => unify (G x) [] (F x) [].

% Nat
unify (uvar as X) [] (succ Y) [] :- !,
    print "succ",
    X = succ N, unify N [] Y [].
unify (uvar as X) [] (natrec N ZE RF) [] :- !,
    print "natrec",
    of (natrec N ZE RF) S _,
    X = natrec N' ZE' RF',
    unify N' [] N [], unify ZE' [] ZE [],
    pi x y\ (of x nat x, of y (S x) y) => unify (RF' x y) [] (RF x y) [].

% List
unify (uvar as X) [] (cns M N) [] :- !,
    X = cns P Q,
    unify P [] M [], unify Q [] N [].
unify (uvar as X) [] (listrec S C D E) [] :- !,
    of C A _,
    X = listrec S C' D' E',
    unify C' [] C [], unify D' [] D [],
    pi x y z\ (of x A x, of y (list A) y, of z (S y) z) => unify (E' x y z) [] (E x y z) [].

% Const
unify (uvar as X) [] T [] :- !, print "const" X T, not (name T), X = T.

% Simmetric case
unify T L' (uvar as X) L :- !, unify X L T L'.


constraint read-copies copy {
    rule (Ctx ?- read-copies)
    | (print "copies: " Ctx).

    rule (E: Ctx ?- copy V R)
    | (climb_telescope Ctx V V', print Ctx V V' R)
    <=> (E: Ctx ?- R = V').
}

mode (climb_telescope i i o).
climb_telescope A B C :- print (climb_telescope A B C), fail.
climb_telescope [] V V.
climb_telescope [copy X Y|Ctx] X Y :- not (name Y).
climb_telescope [copy X Y|Ctx] X R :- !, climb_telescope Ctx Y R.
climb_telescope [_|Ctx] V R :- !, climb_telescope Ctx V R.
