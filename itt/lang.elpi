% IDEA: creare kind set, type star set, poi tipare term -> set -> o i tipi
kind term type. % everything is a term

% Proc definitions (intro and elim will define of, eq will define step, steps, conv)

% typing
type of term -> term -> o.
mode (of i o).
%of T T' :- print (of T T'), fail. 
of (uvar as X) T :- declare_constraint (of X T) [X].

% one step conversion
mode (step i o).
step X Y :- print (step X Y), fail.

% multiple step conversion
mode (steps i o).
steps X Y :- print (steps X Y), fail.
steps M N :- step M M', !, steps M' N.
steps M M.

% rules for term equivalence
mode (conv i i).
conv X Y :- print (conv X Y), fail.
%mode (conv i i).
%conv M N :- steps M M', steps N N', M' = N'.

macro @typ :- term.
macro @dtyp :- (term -> @typ).

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

% FORMATION
type prod @typ -> @dtyp -> term.
%macro @arr A B :- prod A (x\ B).

% INTRODUCTION
%type lam term -> (term -> term) -> term.
type lam @typ -> (term -> term) -> term.
of (lam A F) (prod A B) :- pi x\ of x A => of (F x) (B x).
%conv (lam A F) (lam A G) :- pi x\ conv (F x) (G x).

% ELIMINATION
type app @typ -> term -> term -> term.
of (app (prod A B) F G) (B G) :- of F (prod A B), of G A.
% app with annotation to help unification
%type app term -> term -> term.
%of (app F G) (B G) :- of F (prod A B), of G A.
%conv (app M N) (app M' N') :- conv M M', conv N N'.

% EQUALITY
%step (app (lam _A F) X) (F X).
%step (app L X) R :- steps L (lam _A F), step (app (lam _A F) X) R.
%conv (lam _A (x\ app S x)) S.

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% PROBLEMA: praticamente bisogna specificare tutto a mano, non c'e' altro modo?

% FORMATION
type sum term -> (term -> term) -> term.

% INTRODUCTION
%type pair term -> term -> term.
%of (pair X Y) (sum A B) :- of X A, of Y (B X).
type pair @typ -> (term -> term) -> term -> term -> term.
of (pair A B X Y) (sum A B) :- of X A, of Y (B X).

% ELIMINATION
type split term -> (term -> term -> term) -> term.
of (split P F) (C X Y) :- 
    of P (sum A B),
    P = pair A B X Y,
    pi x y\ (of x A, of y (B x)) => of (F x y) (C x y).

% EQUALITY
step (split (pair _A _B X Y) F) (F X Y).
step (split P F) R :-
    steps P (pair _A _B X Y), 
    step (split (pair _A _B X Y) F) R.
% eta rule? we don't have first and second projection given these rules

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

% FORMATION
%type eq term -> term -> term -> term.

% INTRODUCTION
% ML dice che non importa cosa sia r \in Id(A, a, b) se a =_A b, quindi boh 
%type refl term -> term -> term.
%of (refl A X) (eq A X X) :- conv X X. % ???

% ELIMINATION
% C da dove lo tiro fuori?
%conv X Y :- of C (eq _A X Y).

% EQUALITY


% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

% FORMATION
type nat term.

% INTRODUCTION
type zero term.
type succ term -> term.
of zero nat.
of (succ N) nat :- of N nat.

%type nat_elim ...

% EQUALITY
