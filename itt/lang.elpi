% IDEA: creare kind set, type star set, poi tipare term -> set -> o i tipi
kind term type. % everything is a term

% Proc definitions (intro and elim will define of, eq will define step, steps, conv)

% typing
type of term -> term -> o.
mode (of i o).
%of T T' :- print (of T T'), fail. 
of (uvar as X) T :- declare_constraint (of X T) [X].

% one step conversion
mode (step i o).
step X Y :- print (step X Y), fail.

% multiple step conversion
mode (steps i o).
steps X Y :- print (steps X Y), fail.
steps M N :- step M M', !, steps M' N.
steps M M.

% rules for term equivalence
mode (conv i i).
conv X Y :- print (conv X Y), fail.
%mode (conv i i).
%conv M N :- steps M M', steps N N', M' = N'.


% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

% FORMATION
type prod term -> (term -> term) -> term.
%macro @arr A B :- prod A (x\ B).

% INTRODUCTION
% type lam term -> (term -> term) -> term.
type lam string -> term -> (term -> term) -> (term -> term) -> term.
of (lam Name T1 T2 Body) (prod T1 T2) :- pi x\ of x T1 => of (Body x) (T2 x).
%conv (lam A F) (lam A G) :- pi x\ conv (F x) (G x).

% ELIMINATION
%type app term -> term -> term -> term.
type app term -> (term -> term) -> term -> term -> term.
of (app T1 T2 Lambda Arg) (T2 Arg) :- of Lambda (prod T1 T2), of Arg T1.
%conv (app M N) (app M' N') :- conv M M', conv N N'.

% EQUALITY
%step (app (lam _A F) X) (F X).
%step (app L X) R :- steps L (lam _A F), step (app (lam _A F) X) R.
%conv (lam _A (x\ app S x)) S.

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% FORMATION
type sum term -> (term -> term) -> term.

% INTRODUCTION
type pair term -> (term -> term) -> term -> term -> term.
of (pair Tl Tr El Er) (sum Tl Tr) :- of El Tl, of Er (Tr El).

% ELIMINATION
type split term -> (term -> term) -> (term -> term) -> term -> string -> string -> (term -> term -> term) -> term.
of (split Tl Tr T Pair VarName1 VarName2 Func) (T Pair) :- 
    of Pair (sum Tl Tr),
    pi x y\ (of x Tl, of y (Tr x)) => of (Func x y) (T (pair Tl Tr x y)).

type fst term -> term.
type snd term -> term.
of (fst Pair) Tl :- of Pair (sum Tl Tr).
of (snd Pair) (Tr (snd Pair)) :- of Pair (sum Tl Tr).

% EQUALITY
%step (split _C (pair _A _B X Y) F) (F X Y).
%step (split _C P F) R :-
%    steps P (pair _A _B X Y), 
%    step (split _C (pair _A _B X Y) F) R.
% step e conv anche di first e second

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

% FORMATION
%type id term -> term -> term -> term.

% INTRODUCTION
% T e x El(T) ==> Id(T, x, x)
%type refl term -> term -> term.
%of (refl T X) (id T X X) :- of X T.

% ELIMINATION
%type idpeel term -> term -> term -> term -> (term -> term -> term -> term) -> (term -> term) -> term.
%of (idpeel A X Y Proof C Func) (C X Y Proof) :-
%    of Proof (id A X Y),
%    pi x\ of (Func x) (C x x (refl A x)).

% EQUALITY


% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

% FORMATION
type nat term.

% INTRODUCTION
type zero term.
type succ term -> term.
of zero nat.
of (succ N) nat :- of N nat.

conv zero zero.
conv (succ N) (succ M) :- conv N M.

% ELIMINATION
type natrec term -> term -> (term -> term -> term).
of (natrec N ZeroElement RecFun) (T N) :-
    of N nat,
    of ZeroElement (T zero),
    pi x y\ (of x nat, of y (T x)) => of (RecFun x y) (C (succ x)).

% EQUALITY
step (natrec zero ZeroElement RecFun) ZeroElement.
step (natrec N ZeroElement RecFun) ZeroElement :- steps N zero.

step (natrec (succ N) ZeroElement RecFun) (RecFun N (natrec N ZeroElement RecFun)).
step (natrec M ZeroElement RecFun) R :- steps M (succ N), step (natrec (succ N) ZeroElement RecFun) R.

conv (natrec N1 ZeroElement1 RecFun1) (natrec N2 ZeroElement2 RecFun2) :-
    conv N1 N2,
    conv ZeroElement1 ZeroElement2,
    pi x y\ conv (RecFun1 x y) (RecFun2 x y). % ??? 
