% IDEA: creare kind set, type star set, poi tipare term -> set -> o i tipi
kind term type. % everything is a term

% Proc definitions (intro and elim will define of, eq will define step, steps, conv)

% type inference
type of term -> term -> term -> o.
mode (of i o o).
of T T' X :- print (of T T' X), fail. 
of (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X].

% type checking
type isa term -> term -> term -> o.
mode (isa i o o).
isa T T' X :- print (isa T T' X), fail. 
isa (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X].

% -------------- %
% ---- DOTS ---- %
% -------------- %

isa (app Lam dots) T O :- isa Lam T O.
isa (app Lam dots) T O :- !,
 of Lam TY _,
 steps TY (prod _ _),
 isa (app (app Lam Arg) dots) T O.


isa Te Ty OTe :-
 of Te Ty' OTe,
 conv Ty Ty' .

% one step conversion
mode (step i o).
step X Y :- print (step X Y), fail.

% multiple step conversion
mode (steps i o).
steps X Y :- print (steps X Y), fail.
steps M N :- step M M', !, steps M' N.
steps M M.

% rules for term equivalence
mode (conv i i).
conv X Y :- print (conv X Y), fail.
conv X X :- !.
conv (uvar as X) Y :- !, print "XXXXXXXXXXXXXXX", X = Y.
conv X (uvar as Y) :- !, print "XXXXXXXXXXXXXXX", X = Y.
conv M N :- step M M', !, conv M' N.
conv M N :- step N N', !, conv M N'.

% Invariant: conv t1 t2 is called only when
% it is known that conv ty1 ty2 where
% tyi is the type of ti

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

% FORMATION
type prod term -> (term -> term) -> term.
macro @arrow A B :- prod A (x\ B).

% TYPE
ofType (prod A B) :- ofType A, pi x \ of x A x => ofType (B x).
conv (prod T1 Bd) (prod T1' Bd') :- conv T1 T1', pi x\ of x T1 x => conv (Bd x) (Bd' x).

% INTRODUCTION
type lam string -> term -> (term -> term) -> term.
of (lam Name T1 Bd) (prod T1 T2) (lam Name T1 Bd') :- pi x\ of x T1 x => of (Bd x) (T2 x) (Bd' x).
conv (lam _Name T1 Bd) (lam _Name' _T1' _Bd') :- pi x\ of x T1 x => conv (Bd x) (Bd' x).

% ELIMINATION
type app term -> term -> term.
of (app Lam Arg) T2_Arg (app Lam' Arg') :-
  isa Lam (prod T1 T2) Lam',
  isa Arg T1 Arg',
  T2_Arg = T2 Arg'.
conv (app Lam Arg) (app Lam' Arg') :- conv Lam Lam', conv Arg Arg'.

% EQUALITY
step (app Lam Arg) Res :- steps Lam (lam _Name _A Bd), Res = Bd Arg.
% eta-equality
conv (lam _Name A F) F' , conv F' (lam _Name _A F) :- pi x \ of x A x => conv (F x) (app F' x).

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% FORMATION
type sum term -> (term -> term) -> term.

% INTRODUCTION
type pair term -> (term -> term) -> term -> term -> term.
of (pair Tl Tr El Er) (sum Tl Tr) :- of El Tl, of Er (Tr El).
conv (pair _ _ El Er) (pair _ _ El' Er') :- conv El El', conv Er Er'.

% ELIMINATION
type split term -> (term -> term) -> (term -> term) -> term -> string -> string -> (term -> term -> term) -> term.
of (split Tl Tr T Pair VarName1 VarName2 Func) (T Pair) :- 
    of Pair (sum Tl Tr),
    pi x y\ (of x Tl, of y (Tr x)) => of (Func x y) (T (pair Tl Tr x y)).
conv (split _ _ _ Pair _ _ Func) (split  _ _ _ Pair' _ _ Func') :-
    conv Pair Pair',
    pi x y\ conv (Func x y) (Func' x y).

type fst term -> term.
type snd term -> term.
of (fst Pair) Tl :- of Pair (sum Tl Tr).
of (snd Pair) (Tr (snd Pair)) :- of Pair (sum Tl Tr).

conv (fst P) (fst P') :- conv P P'.
conv (snd P) (snd P') :- conv P P'.

% EQUALITY
% sento che non ci sono abbastanza _ ancora, ne aggiungo qualcuno di seguito: _ _ _ _ _ _ _ _ _ _ _ 
step (split _ _ _ (pair _ _ X Y) _ _ F) (F X Y).
step (split _ _ _ P _ _ F) R :-
    steps P (pair _ _ X Y),
    step (split  _ _ _ (pair _ _ X Y) _ _ F) R.

step (fst (pair _ _ X Y)) X.
step (fst P) X :- steps P (pair _ _ X _Y).
step (snd (pair _ _ X Y)) Y.
step (snd P) Y :- steps P (pair _ _ _X Y).

% conv P (pair _ _ (fst P) (snd P)). % eta sulle coppie

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

% FORMATION
type id term -> term -> term -> term.

% INTRODUCTION
type refl term -> term -> term.
of (refl T X) (id T X X) :- of X T.
%of (refl A X) (id A X Y) :- of X A, of Y A, conv X Y. % ??????

% ELIMINATION
type idpeel term -> term -> term -> term -> (term -> term -> term -> term) -> (term -> term) -> term.
of (idpeel A X Y Proof C Func) (C X Y Proof) :-
    of Proof (id A X Y),
    pi x\ of (Func x) (C x x (refl A x)).

% EQUALITY
step (idpeel _A X _Y (refl _A X) _C Func) (Func X).
step (idpeel _A X _Y Proof _C Func) R :-
    steps Proof (refl _ X),
    step (idpeel _ X _ (refl _ X) _ Func) R.


% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

% FORMATION
type nat term.

% INTRODUCTION
type zero term.
type succ term -> term.
of zero nat.
of (succ N) nat :- of N nat.

conv zero zero.
conv (succ N) (succ M) :- conv N M.

% ELIMINATION
type natrec term -> term -> string -> string -> (term -> term -> term).
of (natrec N ZeroElement VarName1 VarName2 RecFun) (T N) :-
    of N nat,
    of ZeroElement (T zero),
    pi x y\ (of x nat, of y (T x)) => of (RecFun x y) (T (succ x)).

% EQUALITY
step (natrec zero ZeroElement _ _ RecFun) ZeroElement.
step (natrec N ZeroElement _ _ RecFun) ZeroElement :- steps N zero.

step (natrec (succ N) ZeroElement _ _ RecFun) (RecFun N (natrec N ZeroElement _ _ RecFun)).
step (natrec M ZeroElement _ _ RecFun) R :- steps M (succ N), step (natrec (succ N) ZeroElement _ _ RecFun) R.

conv (natrec N1 ZeroElement1 _ _ RecFun1) (natrec N2 ZeroElement2 _ _ RecFun2) :-
    conv N1 N2,
    conv ZeroElement1 ZeroElement2,
    pi x y\ conv (RecFun1 x y) (RecFun2 x y). % ??? 
