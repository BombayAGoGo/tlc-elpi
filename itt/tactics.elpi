accumulate lang.

% This is not the code you are looking for
get_var_name Msg Name :-
    print Msg, read VarName, term_to_string VarName Name.

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %


% return a lambda abstraction, prove (F x)
tactic intro (lam Name T1 T2 Body) Vars K :-
    get_var_name "input lambda var name" Name,
    pi x \ K [([x|Vars], (Body x))].


% ---- APP TACTICS ----
% app when I don't have an immediate function
tactic app (app T1 T2 Lambda Arg) Vars K :-
    K [(Vars, Lambda), (Vars, Arg)].

% app when I have a function as an hypothesis
tactic (app N) (app T1 T2 Lambda Arg) Vars K :-
    nth_element N Vars Lambda,
    K [(Vars, Arg)].

% app when I know everything
tactic (app N M) (app T1 T2 Lambda Arg) Vars K :-
    nth_element N Vars Lambda,
    nth_element M Vars Arg,
    K [].


% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% of (pair A B X Y) (sum A B) :- of X A, of Y (B X).
% of (split (pair A B X Y) F) (C X Y) :-

tactic andEL (fst P) Vars K :-
    K [(Vars, P)].
tactic andER (snd P) Vars K :-
    K [(Vars, P)].

% and elimination but with hypothesis use
tactic (andEL N) (fst H) Vars K :-
    nth_element N Vars H,
    K [].
tactic (andER N) (snd H) Vars K :-
    nth_element N Vars H,
    K [].

tactic andE (split A B C P VarName1 VarName2 F) Vars K :-
    get_var_name "input func var name 1" VarName1,
    get_var_name "input func var name 2" VarName2,
    pi x y\
        K [(Vars, P), ([x, y|Vars], (F x y))].

tactic andI (pair A B X Y) Vars K :-
    K [(Vars, X), (Vars, Y)].

% and intro with hyp use
tactic (andI N M) (pair A B H G) Vars K :-
    nth_element N Vars H,
    nth_element M Vars G,
    K [].


% -------------------- %
% ---- HYPOTHESIS ---- %
% -------------------- %

tactic (var N) H Vars K :-
    nth_element N Vars H,
    K [].


% Error
%tactic Name H Vars K :- 
%    print "Error, something went wrong with " Name,
%    print H,
%    print Vars,
%    print K.
