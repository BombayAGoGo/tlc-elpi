% TODO:
% - change subst with unification (?)

kind term type.

% ------------------------ %
% ---- TYPE INFERENCE ---- %
% ------------------------ %

pred of i:term, o:term, o:term.
of X T Y :- print (of X T Y), fail. 
of (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X, Y].

% ----------------------- %
% ---- TYPE CHECKING ---- %
% ----------------------- %

pred isa i:term, o:term, o:term.
isa X T Y :- print (isa X T Y), fail. 
isa (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X, Y].

% -------------- %
% ---- DOTS ---- %
% -------------- %

isa (app Lam dots) T O :- isa Lam T O.
isa (app Lam dots) T O :- !,
    isa Lam (prod _ _) _,
    isa (app (app Lam Arg) dots) T O.


isa Te Ty OTe :-
    conv Ty Ty',
    of Te Ty' OTe.

of_type T :- print (of_type T), fail.

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

% FORMATION
type prod term -> (term -> term) -> term.
macro @arrow A B :- prod A (x\ B).

% TYPE
of_type (prod A B) :- of_type A, pi x\ of x A x => of_type (B x).

% INTRODUCTION
type lam term -> (term -> term) -> term.
of (lam A Bd) (prod A B) (lam A Bd') :- pi x\ of x A x => isa (Bd x) (B x) (Bd' x).

% ELIMINATION
type app term -> term -> term.
of (app Lam Arg) B_Arg (app Lam' Arg') :-
    isa Lam (prod A B) Lam',
    isa Arg A Arg',
    pi x\ (of x A x, copy x Arg) => conv (B x) B_Arg.
    %unify B [Arg] B_Arg [].
    %subst B [Arg] B_Arg.

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% FORMATION
type sum term -> (term -> term) -> term.
macro @times A B :- sum A (x\ B).

% TYPE
of_type (sum A B) :- of_type A, pi x\ of x A x => of_type (B x).

% INTRODUCTION

type pair term -> term -> term.
of (pair Left Right) (sum A B) (pair Left' Right') :- 
    isa Left A Left',
    isa Right B_Left Right',
    pi x\ (of x A x, copy x Left) => conv (B x) B_Left.
    %subst B [Left] B_Left.

% ELIMINATION
type split term -> (term -> term -> term) -> term.
of (split Pair Func) T_Pair (split Pair' Func') :- 
    isa Pair (sum A B) Pair',
    pi p\ (of p (sum A B) p, copy p Pair) => conv (T p) T_Pair,
    %subst T [Pair] T_Pair,
    pi x y\ (of x A x, of y (B x) y) => (
        isa (Func x y) TSubst (Func' x y),
        pi p\ (of p (sum A B) p, copy p (pair x y)) => conv (T p)  TSubst
        %subst T [pair x y] TSubst
    ).

type fst term -> term.
of (fst Pair) A (fst Pair') :-
    isa Pair (sum A B) Pair'.

type snd term -> term.
of (snd Pair) B_fst (snd Pair') :-
    isa Pair (sum A B) Pair',
    % XXX: Pair = pair P Q
    pi f\ (of f A f, copy f (fst Pair)) => conv (B f) B_fst.
    %subst B [fst Pair] B_fst.

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

% FORMATION
type id term -> term -> term -> term.
of_type (id A X Y) :- of_type A, isa X A _, isa Y A _.

% INTRODUCTION
type refl term -> term -> term.
of (refl A X) (id A X X) (refl A X') :- isa X A X'.

% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

% FORMATION
type nat term.
of_type nat.

% INTRODUCTION
type zero term.
type succ term -> term.
of zero nat zero.
of (succ N) nat (succ N') :- isa N nat N'.

% ELIMINATION
type natrec term -> term -> (term -> term -> term) -> term.
of (natrec N ZE RF) T_N (natrec N' ZE' RF') :-
    isa N nat N',
    pi x y\ (of x nat x, of y (T x) y) => (
        isa (RF x y) T_Succ (RF' x y),
        pi s\ (of s nat s, copy s (succ x)) => conv (T s) T_Succ
        %subst T [succ x] T_Succ
    ),
    isa ZE (T zero) ZE',
    pi n\ (of n nat n, copy n N) => conv (T n) T_N.
    %subst T [N] T_N.

% -------------------------- %
% ---- ELABORATOR TERMS ---- %
% -------------------------- %

type lam string -> term -> (term -> term) -> term.
of (lam Name A Bd) Prod (lam Name A Bd') :- of (lam A Bd) Prod (lam A Bd').

type split term -> string -> string -> (term -> term -> term) -> term.
of (split Pair Name1 Name2 Func) T_Pair (split Pair' Name1 Name2 Func') :- 
    of (split Pair Func) T_Pair (split Pair' Func').

type natrec term -> term -> string -> string -> (term -> term -> term) -> term.
of (natrec N ZE Name1 Name2 RF) T_N (natrec N' ZE' Name1 Name2 RF') :-
    of (natrec N ZE RF) T_N (natrec N' ZE' RF').
