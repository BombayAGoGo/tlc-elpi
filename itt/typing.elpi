% TODO:
% - change subst with unification (?)

kind term type.

% ------------------------ %
% ---- TYPE INFERENCE ---- %
% ------------------------ %

pred of i:term, o:term, o:term.
%of X T Y :- print (of X T Y), fail. 
of (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X, Y].

% ----------------------- %
% ---- TYPE CHECKING ---- %
% ----------------------- %

pred isa i:term, o:term, o:term.
%isa X T Y :- print (isa X T Y), fail. 
isa (uvar as X) T Y :- !, declare_constraint (isa X T Y) [X, Y].

% -------------- %
% ---- DOTS ---- %
% -------------- %

isa (app Lam dots) T O :- isa Lam T O.
isa (app Lam dots) T O :- !,
    isa Lam (prod _ _) _,
    isa (app (app Lam Arg) dots) T O.


isa Te Ty OTe :-
    conv Ty Ty',
    of Te Ty' OTe.

of_type T :- print (of_type T), fail.

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

% FORMATION
type prod term -> (term -> term) -> term.
macro @arrow A B :- prod A (x\ B).

% TYPE
of_type (prod A B) :- of_type A, pi x\ of x A x => of_type (B x).

% INTRODUCTION
type lam string -> term -> (term -> term) -> term.
of (lam Name A Bd) (prod A B) (lam Name A Bd') :- pi x\ of x A x => isa (Bd x) (B x) (Bd' x).

% ELIMINATION
type app term -> term -> term.
of (app Lam Arg) B_Arg (app Lam' Arg') :-
    isa Lam (prod A B) Lam',
    isa Arg A Arg',
    subst B [Arg] B_Arg.

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

% FORMATION
type sum term -> (term -> term) -> term.
macro @times A B :- sum A (x\ B).

% TYPE
of_type (sum A B) :- of_type A, pi x\ of x A x => of_type (B x).

% INTRODUCTION

type pair term -> term -> term.
of (pair Left Right) (sum A B) (pair Left' Right') :- 
    isa Left A Left',
    isa Right B_Left Right',
    subst B [Left] B_Left.

% ELIMINATION
type split term -> string -> string -> (term -> term -> term) -> term.
of (split Pair Name1 Name2 Func) T_Pair (split Pair' Name1 Name2 Func') :- 
    isa Pair (sum A B) Pair',
    subst T [Pair] T_Pair,
    pi x y\ (of x A x, of y (B x) y) => (
        isa (Func x y) TSubst (Func' x y),
        subst T [pair x y] TSubst
    ).

type fst term -> term.
of (fst Pair) A (fst Pair') :-
    isa Pair (sum A B) Pair'.

type snd term -> term.
of (snd Pair) B_fst (fst Pair') :-
    isa Pair (sum A B) Pair',
    subst B (fst Pair) B_fst.

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

% FORMATION
type id term -> term -> term -> term.
of_type (id A X Y) :- of_type A, isa X A _, isa Y A _.

% INTRODUCTION
type refl term -> term -> term.
of (refl A X) (id A X X) (refl A X') :- isa X A X'.

% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

% FORMATION
type nat term.
of_type nat.

% INTRODUCTION
type zero term.
type succ term -> term.
of zero nat zero.
of (succ N) nat (succ N') :- isa N nat N'.

% ELIMINATION
type natrec term -> term -> string -> string -> (term -> term -> term) -> term.
of (natrec N ZeroElement Name1 Name2 RecFun) T_N (natrec T N' ZeroElement' Name1 Name2 RecFun') :-
    isa N nat N',
    pi x y\ (of x nat x, of y (T x) y) => (
        isa (RecFun x y) T_Succ (RecFun' x y),
        subst T [succ x] T_Succ
    ),
    isa ZeroElement (T zero) ZeroElement',
    subst T [N] T_N.
