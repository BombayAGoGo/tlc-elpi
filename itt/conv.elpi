% --------------- %
% ---- STEPS ---- %
% --------------- %

% one step conversion
mode (step i o).
step X Y :- print (step X Y), fail.

% multiple step conversion
mode (steps i o).
steps X Y :- print (steps X Y), fail.
steps M N :- step M M', !, steps M' N.
steps M M.

% -------------- %
% ---- CONV ---- %
% -------------- %

% Invariant: conv t₁ t₂ is called only when it is known that conv ty₁ ty₂ where
% ty_i is the type of t_i

% term equivalence
mode (conv i i).
conv X Y :- print (conv X Y), fail.

conv M N :- !.
conv M N :- step M M', !, conv M' N.
conv M N :- step N N', !, conv M N'.

% --------------------------- %
% ---- CARTESIAN PRODUCT ---- %
% --------------------------- %

conv (prod A B) (prod A' B') :- conv A A', pi x\ of x A x => conv (B x) (B' x).

conv (lam _Name A Bd) (lam _Name' _A' Bd') :- pi x\ of x A x => conv (Bd x) (Bd' x).
conv (app Lam Arg)    (app Lam' Arg')      :- conv Lam Lam', conv Arg Arg'.

% BETA
step (app Lam Arg) R :-
    steps Lam (lam _Name _A Bd),
    subst Bd [Arg] S,
    steps S R.

% ETA EQUALITY
conv (lam _Name A F) F' :- pi x \ of x A x => conv (F x) (app F' x).
conv F' (lam _Name A F) :- pi x \ of x A x => conv (F x) (app F' x).

% ------------------------ %
% ---- DISJOINT UNION ---- %
% ------------------------ %

conv (sum A B) (sum A' B') :- conv A A', pi x\ of x A x => conv (B x) (B' x).

conv (pair Left Right) (pair Left' Right') :-
    conv Left Left',
    conv Right Right'.

conv (split Pair _Name1 _Name2 Func) (split Pair' _Name1 _Name2 Func') :-
    conv Pair Pair',
    %isa Pair (sum A B) _,
    pi x y\ (of x A x, of y (B x) y) => conv (Func x y) (Func' x y).

conv (fst Pair) (fst Pair') :- conv Pair Pair'.
conv (snd Pair) (snd Pair') :- conv Pair Pair'.

% BETA
step (split P _ _ F) R :-
    steps P (pair X Y),
    subst F [X, Y] R.
step (fst P) X :- steps P (pair X Y).
step (snd P) Y :- steps P (pair X Y).

% ETA EQUALITY
conv P (pair (fst P) (snd P)).
conv (pair (fst P) (snd P)) P.

% -------------------------------- %
% ---- PROPOSITIONAL EQUALITY ---- %
% -------------------------------- %

%conv X Y :- isa Magic (id A X Y) _.
%conv Magic (refl A X) :- isa Magic (id A X Y) _.

% ------------------ %
% ---- NATURALS ---- %
% ------------------ %

conv (succ N) (succ M) :- conv N M.

conv (natrec N1 ZeroElement1 _ _ RecFun1) (natrec _T N2 ZeroElement2 _ _ RecFun2) :-
    conv N1 N2,
    conv ZeroElement1 ZeroElement2,
    pi x y\ (of x nat x, of y (T x) y) => conv (RecFun1 x y) (RecFun2 x y).

% BETA
step (natrec N ZeroElement _ _ RecFun) ZeroElement :- steps N zero.
step (natrec M ZeroElement _ _ RecFun) R :-
    steps M (succ N),
    steps (natrec N ZeroElement _ _ RecFun) R',
    subst RecFun [N, R'] S,
    steps S R.
