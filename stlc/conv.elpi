% ---------------------------- %
% ---- ONE STEP REDUCTION ---- %
% ---------------------------- %

mode (step i o).
%step X Y :- print (step X Y), fail.

% App
step (app M N) R :- steps M (lam T F), subst F [N] R. %R = F N.

% Pairs
step (fst Pair) M :- steps Pair (pair M N).
step (snd Pair) N :- steps Pair (pair M N).

% Case
step (case Sum U V) (U R) :- steps Sum (inl _T2 R).
step (case Sum U V) (V S) :- steps Sum (inr _T1 S).

% Natrec
step (natrec Z ZE _Fun) ZE :- steps Z zero.
step (natrec S ZE Fun) R :-
    steps S (succ N),
    steps (natrec N ZE Fun) RecRes,
    subst Fun [N, RecRes] R.
    %R = Fun N RecRes.

% If then else
step (ite Cond Then Else) Then :- steps Cond tt.
step (ite Cond Then Else) Else :- steps Cond ff.

% ------------------- %
% ---- ETA RULES ---- %
% ------------------- %

%TODO: eta rules

% ------------------------------ %
% ---- MULTI STEP REDUCTION ---- %
% ------------------------------ %

mode (steps i o).
%steps X Y :- print (steps X Y), fail.

% normalization of a list of arguments
steps [] [].
steps [M|MS] [M'|MS'] :- steps M M', steps MS MS'.

steps M N :- step M M', !, steps M' N.
steps M M.

% ------------------------- %
% ---- TYPE CONVERSION ---- %
% ------------------------- %

mode (conv i i).
%conv X Y :- print (conv X Y), fail.

conv (arr A B) (arr C D) :- conv A C, conv B D.
conv (prod A B) (prod C D) :- conv A C, conv B D.
conv (sum A B) (sum C D) :- conv A C, conv B D.
conv (void A) (void B) :- conv A B.
conv unit unit.
conv nat nat.
conv bool bool.

% ------------------------- %
% ---- TERM CONVERSION ---- %
% ------------------------- %

% INVARIANT: we assume terms are typed beforehand
% and that conversion is only asked between terms
% with convertible types.
% TODO: different unification for types and terms


% FLEX - FLEX
conv (uvar as X) (uvar as Y) :- !, declare_constraint (conv X Y) [X, Y].

%conv (app (uvar as X) N) T :- unify (app X N) [] T [].
%conv T (app (uvar as X) N) :- unify (app X N) [] T [].
%conv (uvar as X) T :- !, unify X [] T [].
%conv T (uvar as X) :- !, unify X [] T [].

/*
% FLEX - "RIGID"
conv (uvar K L) T :- !,
    steps T T',     % term has to be normal
    steps L L',     % meta args have to be normal
    subst K L T'.
% "RIGID" - FLEX
conv T (uvar K L) :- !,
    steps T T',
    steps L L',
    subst K L T'.
*/

conv (app M1 N1) (app M2 N2) :- conv M1 M2, conv N1 N2.
conv (lam T F1) (lam T F2) :- pi x\ of x T x => conv (F1 x) (F2 x).

conv (pair M1 N1) (pair M2 N2) :- conv M1 M2, conv N1 N2.

conv (fst P1) (fst P2) :- conv P1 P2.
conv (snd P1) (snd P2) :- conv P1 P2.

conv (inl _ S1) (inl _ S2) :- conv S1 S2.
conv (inr _ S1) (inr _ S2) :- conv S1 S2.

conv (case M1 F1 G1) (case M2 F2 G2) :-
    conv M1 M2,
    pi x\ conv (F1 x) (F2 x),
    pi x\ conv (G1 x) (G2 x).

conv zero zero.
conv (succ N1) (succ N2) :- conv N1 N2.
conv (natrec N1 ZE1 F1) (natrec N2 ZE2 F2) :-
    conv N1 N2,
    conv ZE1 ZE2,
    pi x y\ conv (F1 x y) (F2 x y).

conv tt tt.
conv ff ff.
conv (ite C1 T1 E1) (ite C2 T2 E2) :-
    conv C1 C2,
    conv T1 T2,
    conv E1 E2.

% conversion up to reduction
conv M N :- M = N.                      % mode i i won't instantiate
conv M N :- step M M', !, conv M' N.    % at least one-step reduction
conv M N :- step N N', !, conv M N'.
conv M M.
