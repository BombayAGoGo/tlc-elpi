% -------------------- %
% ---- BETA RULES ---- %
% -------------------- %

mode (step i o).
%step X Y :- print (step X Y), fail.

% App
step (app M N) R :- steps M (lam T F), R = F N.

% Pairs
step (fst Pair) M :- steps Pair (pair M N).
step (snd Pair) N :- steps Pair (pair M N).

% Case
step (case Sum U V) (U R) :- steps Sum (inl _T2 R).
step (case Sum U V) (V S) :- steps Sum (inr _T1 S).

% Natrec
step (natrec Z ZE _Fun) ZE :- steps Z zero.
step (natrec S ZE Fun) R :-
    steps S (succ N),
    steps (natrec N ZE Fun) RecRes,
    R = Fun N RecRes.

% If then else
step (ite Cond Then Else) Then :- steps Cond tt.
step (ite Cond Then Else) Else :- steps Cond ff.

% ------------------- %
% ---- ETA RULES ---- %
% ------------------- %

%mode (eta_step i o).
%eta_step (of M (arr A B)) (lam A (u \ M u)).
%eta_step (of M (prod A B)) (pair (fst M) (snd M)).
%eta_step (of M (sum A B)) (case M (u \ inl B u) (v \ inr A w)).
%eta_step (of M unit) singleton.
%eta_step (of M void) (abort void M).

mode (steps i o).
%steps X Y :- print (steps X Y), fail.
steps M N :- step M M', !, steps M' N.
steps M M.

% ---------------- %
% ---- NUCLEO ---- %
% ---------------- %

mode (conv i i).
%conv X Y :- print (conv X Y), fail.

% ------------------------- %
% ---- TYPE CONVERSION ---- %
% ------------------------- %

% praticamente inutile pero' isa chiama comunque conv sui tipi e boh...
% probabilmente da rimuovere
conv (arr A B) (arr C D) :- conv A C, conv B D.
conv (prod A B) (prod C D) :- conv A C, conv B D.
conv (sum A B) (sum C D) :- conv A C, conv B D.
conv (void A) (void B) :- conv A B.
conv unit unit.
conv nat nat.
conv bool bool.

% ------------------------- %
% ---- TERM CONVERSION ---- %
% ------------------------- %

conv (app M1 N1) (app M2 N2) :- conv M1 M2, conv N1 N2.
conv (lam _ F1) (lam _ F2) :- pi x \ conv (F1 x) (F2 x).

conv (pair M1 N1) (pair M2 N2) :- conv M1 M2, conv N1 N2.

conv (fst P1) (fst P2) :- conv P1 P2.
conv (snd P1) (snd P2) :- conv P1 P2.

conv (inl _ S1) (inl _ S2) :- conv S1 S2.
conv (inr _ S1) (inr _ S2) :- conv S1 S2.

conv (case M1 F1 G1) (case M2 F2 G2) :-
    conv M1 M2,
    pi x\ conv (F1 x) (F2 x),
    pi x\ conv (G1 x) (G2 x).

conv zero zero.
conv (succ N1) (succ N2) :- conv N1 N2.
conv (natrec N1 ZE1 F1) (natrec N2 ZE2 F2) :-
    conv N1 N2,
    conv ZE1 ZE2,
    pi x y\ conv (F1 x y) (F2 x y).

conv tt tt.
conv ff ff.
conv (ite C1 T1 E1) (ite C2 T2 E2) :-
    conv C1 C2,
    conv T1 T2,
    conv E1 E2.

conv M N :- M = N. % i i => non vuole istanziare
conv M N :- step M M', !, conv M' N.
conv M N :- step N N', !, conv M N'.
conv M M.
