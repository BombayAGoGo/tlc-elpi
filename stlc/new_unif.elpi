% TODO:
% - controllo del tipaggio
% - se fai unify app (lam T F) T' --> pi x\ copy x T' => unify ... (F x)

% ------------------------ %
% ---- STEP EXTENSION ---- %
% ------------------------ %

% XXX: non sicuro di cosa mettere (idea e' che non dovrebbe fare nulla)
step (app (uvar as M) N) (app M N) :- !.
steps (app (uvar as M) N) (app M N) :- !.
step (app (lam T (uvar as F)) M) (app (lam T F) M) :- !.
steps (app (lam T (uvar as F)) M) (app (lam T F) M) :- !.

% ------------------------ %
% ---- CONV EXTENSION ---- %
% ------------------------ %

% FLEX - FLEX
conv (uvar as X) (uvar as Y) :- !, declare_constraint (conv X Y) [X, Y].

conv (app (uvar as X) N) T :- !, steps T T', unify X [N] T' [].
conv T (app (uvar as X) N) :- !, steps T T', unify X [N] T' [].
conv (uvar as X) T :- !, steps T T', unify X [] T' [].
conv T (uvar as X) :- !, steps T T', unify X [] T' [].

% XXX: intercetto i Î²-redessi per poi mettere predicati copia e fare una
%      sostituzione "safe"
conv T (app (lam A F) S) :- !, pi x\ copy x S => conv T (F x).
conv (app (lam A F) S) T :- !, pi x\ copy x S => conv T (F x).

/*
% FLEX - "RIGID"
conv (uvar K L) T :- !,
    steps T T',     % term has to be normal
    steps L L',     % meta args have to be normal
    subst K L T'.
% "RIGID" - FLEX
conv T (uvar K L) :- !,
    steps T T',
    steps L L',
    subst K L T'.
*/

% --------------------- %
% ---- UNIFICATION ---- %
% --------------------- %

mode (unify i i i i).
unify A B C D :- print (unify A B C D), fail.

% delay flex-flex
unify (uvar as X) L (uvar as Y) L' :- declare_constraint (unify X L Y L') [X, Y].

unify T L (app (lam A F) X) L' :-
    pi x\ copy x X => unify T L (F x) L'.
unify (app (lam A F) X) L T L' :-
    pi x\ copy x X => unify (F x) L T L'.

% unwind app
unify (app X Y) L T L' :- !,
    append [Y] L LY,
    unify X LY T L'.
unify T L' (app X Y) L :- !,
    append [Y] L LY,
    unify T L' X LY.

mode (rewind_app i i o).
rewind_app A [] A.
rewind_app T [L|Ls] A :-
    rewind_app (app T L) Ls A.

% ---- TYPE UNIFICATION ---- %

% in stlc we just copy types
unify (uvar as X) [] nat [] :- !, X = nat.
unify (uvar as X) [] (arr M N) [] :- !, X = arr M N.

% ---- TERM UNIFICATION ---- %

% PROJECTION
unify (uvar as X) [] Term Arg :-
    copy Var Term',
    rewind_app Term Arg App,
    conv Term' App,
    X = Var.

% MIMIC
% Const/Eigenvar
unify (uvar as X) [] T [] :- !, X = T.
% App
unify (uvar as X) [] T [A|As] :-
    X = app M N,
    append Body [Tail] [A|As],
    unify M [] T Body,
    unify N [] Tail [].
unify (uvar as X) [] (lam T F) [] :-
    X = lam T G,
    pi x\ unify (G x) [] (F x) [].

% Meta with args is a lambda
unify (uvar as X) [L|Ls] T L' :- !,
    isa L LTy _,
    X = lam LTy F,
    pi x\ copy x L => unify (F x) Ls T L'.

% Simmetric case
unify T L' (uvar as X) L :- !, unify X L T L'.
