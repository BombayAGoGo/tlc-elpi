% TODO:
% - provare a debuggare esempi che non vanno
% - provare a portare sta roba al calcolo dipendente
% - provare a scrivere regole che usano distruttori su input (es. fst pair)

% ------------------------ %
% ---- STEP EXTENSION ---- %
% ------------------------ %

% XXX: non sicuro di cosa mettere (idea e' che non dovrebbe fare nulla)
% XXX: se ho lam T F dove F contiene meta non vorrei fare step(s)
mode (step i o).
mode (steps i o).
step (app (uvar as M) N) (app M N) :- print "step on app uvar", halt.
steps (app (uvar as M) N) (app M N) :- print "steps on app uvar", halt.
step (app (lam T (uvar as F)) M) (app (lam T F) M) :- print "step on app lam uvar", halt.
steps (app (lam T (uvar as F)) M) (app (lam T F) M) :- print "steps on app lam uvar", halt.

% ------------------------ %
% ---- CONV EXTENSION ---- %
% ------------------------ %

mode (is_stuck i).
is_stuck uvar.
is_stuck (app M _) :- is_stuck M.
is_stuck _ :- fail.

mode (conv i i).
conv X Y :- print (conv X Y), fail.
conv X Y :- is_stuck X, is_stuck Y, !, conv_constraint X Y X Y.
conv X Y :- (is_stuck X, !; is_stuck Y), !, unify X [] Y [].

mode (conv_constraint i i).
conv_constraint (app M N) S A B :- conv_constraint M S A B.
conv_constraint T (app M N) A B :- conv_constraint T M A B. 
conv_constraint (uvar as X) (uvar as Y) A B :- !, declare_constraint (conv A B) [X, Y].

%conv T (app (lam A F) S) :- !, pi x\ (of x A x, copy x S) => conv T (F x).
%conv (app (lam A F) S) T :- !, pi x\ (of x A x, copy x S) => conv T (F x).

% NOTE: if F is closed we can perform Î²-reduction
conv T (app (lam A F) S) :- not (is_closed (lam A F)), !, unify T [] (app (lam A F) S) [].
conv (app (lam A F) S) T :- not (is_closed (lam A F)), !, unify (app (lam A F) S) [] T [].

type is_closed term -> o.
mode (is_closed i).
is_closed uvar :- fail.
is_closed (app M N) :- is_closed M, is_closed N.
is_closed (lam T F) :- pi x\ is_closed (F x).
is_closed (succ N) :- is_closed N.

/*
% FLEX - "RIGID"
conv (uvar K L) T :- !,
    steps T T',     % term has to be normal
    steps L L',     % meta args have to be normal
    subst K L T'.
% "RIGID" - FLEX
conv T (uvar K L) :- !,
    steps T T',
    steps L L',
    subst K L T'.
*/

% --------------------- %
% ---- UNIFICATION ---- %
% --------------------- %

mode (unify i i i i).
unify A B C D :- print (unify A B C D), fail.

% delay flex-flex
%unify (uvar as X) L (uvar as Y) L' :- !, declare_constraint (unify X L Y L') [X, Y].
unify (uvar as X) [] (uvar as Y) [] :- !, declare_constraint (read-copies) [], declare_constraint (unify X [] Y []) [X, Y].

unify T L (app (lam A F) X) L' :- !,
    pi x\ (of x A x, copy x X) => unify T L (F x) L'.
unify (app (lam A F) X) L T L' :- !,
    pi x\ (of x A x, copy x X) => unify (F x) L T L'.

% unwind app
unify (app X Y) L T L' :- !,
    append [Y] L LY,
    unify X LY T L'.
unify T L' (app X Y) L :- !,
    append [Y] L LY,
    unify T L' X LY.

mode (rewind_app i i o).
rewind_app A [] A.
rewind_app T [L|Ls] A :-
    rewind_app (app T L) Ls A.

% Meta with args is a lambda
unify (uvar as X) [L|Ls] T L' :- !, 
    print "inst",
    isa L LTy _,
    X = lam LTy F,
    pi x\ (of x LTy x, copy x L) => unify (F x) Ls T L'.

%unify T L' (uvar as X) [L|Ls] :- !, 
%    print "inst",
%    isa L LTy _,
%    X = lam LTy F,
%    pi x\ (of x LTy x, copy x L) => unify T L' (F x) Ls.

% ---- TYPE UNIFICATION ---- %

% in stlc we just copy types
unify (uvar as X) [] nat [] :- !, X = nat.
unify (uvar as X) [] (arr M N) [] :- !, X = arr M N.

% ---- TERM UNIFICATION ---- %

% PROJECTION
unify (uvar _ Vs as X) [] Term Arg :- print "proj" X Term Arg, rewind_app Term Arg App, try_projection X Vs App.

mode (try_projection i i i).
try_projection _ [] _ :- fail.
try_projection X [V|Vs] App :-
    (get_copy V Term', print "got" V Term', conv Term' App, X = V); try_projection X Vs App.

mode (get_copy i o).
get_copy V X :- declare_constraint (copy V X) [X].

% MIMIC
% App
unify (uvar as X) [] T [A|As] :-
    print "app" X T [A|As],
    X = app M N,
    append Body [Tail] [A|As],
    unify M [] T Body,
    unify N [] Tail [].
unify (uvar as X) [] (lam T F) [] :-
    print "lam",
    X = lam T G, pi x\ unify (G x) [] (F x) [].
unify (uvar as X) [] (succ Y) [] :-
    print "succ" X (succ Y),
    X = succ N, unify N [] Y [].
% Const
unify (uvar as X) [] T [] :- !, print "const" X T, not (name T), X = T.
% Universal variable
% Idea: una variabile quantificata universalmente o e' come input di una meta,
%       e allora proiezione, altrimenti non ha senso istanziare la meta
%unify (uvar as X) [] U [] :- print "univar", fail.

% Simmetric case
unify T L' (uvar as X) L :- !, unify X L T L'.

constraint read-copies copy {
    rule (Ctx ?- read-copies)
    | (print "copies: " Ctx).

    rule 
    \ (E: Ctx ?- copy V R)
    | (climb_telescope Ctx V V')
    <=> (E: Ctx ?- R = V').
}

mode (climb_telescope i i o).
climb_telescope A B C :- print (climb_telescope A B C), fail.
climb_telescope [] V V.
climb_telescope [copy X Y|Ctx] X Y :- not (name Y).
climb_telescope [copy X Y|Ctx] X R :- !, climb_telescope Ctx Y R.
climb_telescope [_|Ctx] V R :- climb_telescope Ctx V R.
