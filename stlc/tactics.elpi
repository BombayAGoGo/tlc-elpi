% ----------------- %
% ---- TACTICS ---- %
% ----------------- %

% TODO: migrate old tactics
% tactic name goals fresh_vars new_goals

tactic (intro N) (goal X (arr A B) RTerm VDecls) FVars NewGoals :-
    X = lam N A F,
    build_newgoals RTerm VDecls NewGoals.

tactic (mapp N) (goal X Type RTerm VDecls) FVars NewGoals :-
    get_named N FVars Lam,
    X = app Lam dots,
    build_newgoals RTerm VDecls NewGoals.

tactic andI (goal X (prod A B) RTerm VDecls) FVars NewGoals :-
    X = pair P Q,
    build_newgoals RTerm VDecls NewGoals.

/*
% return a lambda abstraction, prove (F x)
tactic (intro Name) (lam Z F) Vars K :-
    pi x \ K [([(x, Name)|Vars], (F x))].

% --------------------- %
% ---- APP TACTICS ---- %
% --------------------- %

% app when I don't have an immediate function
tactic app (app H G) Vars K :-
    K [(Vars, G), (Vars, H)].

% app when I have a function as an hypothesis
tactic (app N) (app H G) Vars K :-
    get_named N Vars H,
    K [(Vars, G)].

% app when I know everything
tactic (app N M) (app H G) Vars K :-
    get_named N Vars H,
    get_named M Vars G,
    K [].

tactic (mapp N) X Vars K :-
    get_named N Vars Lambda,
    lookup X Y,
    X = app Lambda dots,
    %print "recuperato" Y "elaborato di" X,
    rec_term Y Vars K.


% --------------------- %
% ---- AND TACTICS ---- %
% --------------------- %

tactic andEL (fst X) Vars K :-
    K [(Vars, X)].
tactic andER (snd X) Vars K :-
    K [(Vars, X)].

% and elimination but with hypothesis use
tactic (andEL N) (fst H) Vars K :-
    get_named N Vars H,
    K [].
tactic (andER N) (snd H) Vars K :-
    get_named N Vars H,
    K [].

tactic andI (pair A B) Vars K :-
    K [(Vars, A), (Vars, B)].

% and intro with hyp use
tactic (andI N M) (pair H I) Vars K :-
    get_named N Vars H,
    get_named M Vars I,
    K [].


% -------------------- %
% ---- OR TACTICS ---- %
% -------------------- %

tactic orIL (inl T2 X) Vars K :-
    K [(Vars, X)].
tactic orIR (inr T1 X) Vars K :-
    K [(Vars, X)].

% or where element is hyp
tactic (orIL N) (inl T2 H) Vars K :-
    get_named N Vars H,
    K [].
tactic (orIR N) (inr T1 H) Vars K :-
    get_named N Vars H,
    K [].

tactic (orE Name1 Name2) (case M F G) Vars K :-
    pi u v \
        K [(Vars, M), ([(u, Name1)|Vars], (F u)), ([(v, Name2)|Vars], (G v))].

% or where sum is hyp
tactic (orE N Name1 Name2) (case H F G) Vars K :-
    get_named N Vars H,
    pi u v \
        K [([(u, Name1)|Vars], (F u)), ([(v, Name2)|Vars], (G v))].    


% ------------------------- %
% ---- TOP/BOT TACTICS ---- %
% ------------------------- %

tactic botE (abort X T) Vars K :-
    K [(Vars, X)].
tactic topI singleton _ K :-
    K []. % ???


% -------------------- %
% ---- HYPOTHESIS ---- %
% -------------------- %

tactic (var N) H Vars K :-
    get_named N Vars H,
    K [].


% Error
tactic Name H Vars K :- 
    print "Error, either" Name "is not a tactic or something was wrong with its args",
    print H,
    print Vars,
    print K.
*/
