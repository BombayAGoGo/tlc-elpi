% return a lambda abstraction, prove (F x)
tactic (intro Name) (lam Z F) Vars K :-
    pi x \ K [([(x, Name)|Vars], (F x))].

% --------------------- %
% ---- APP TACTICS ---- %
% --------------------- %

% app when I don't have an immediate function
tactic app (app H G) Vars K :-
    K [(Vars, G), (Vars, H)].

% app when I have a function as an hypothesis
tactic (app N) (app H G) Vars K :-
    get_named N Vars H,
    K [(Vars, G)].

% app when I know everything
tactic (app N M) (app H G) Vars K :-
    get_named N Vars H,
    get_named M Vars G,
    K [].


% --------------------- %
% ---- AND TACTICS ---- %
% --------------------- %

tactic andEL (fst X) Vars K :-
    K [(Vars, X)].
tactic andER (snd X) Vars K :-
    K [(Vars, X)].

% and elimination but with hypothesis use
tactic (andEL N) (fst H) Vars K :-
    get_named N Vars H,
    K [].
tactic (andER N) (snd H) Vars K :-
    get_named N Vars H,
    K [].

tactic andI (pair A B) Vars K :-
    K [(Vars, A), (Vars, B)].

% and intro with hyp use
tactic (andI N M) (pair H I) Vars K :-
    get_named N Vars H,
    get_named M Vars I,
    K [].


% -------------------- %
% ---- OR TACTICS ---- %
% -------------------- %

tactic orIL (inl T2 X) Vars K :-
    K [(Vars, X)].
tactic orIR (inr T1 X) Vars K :-
    K [(Vars, X)].

% or where element is hyp
tactic (orIL N) (inl T2 H) Vars K :-
    get_named N Vars H,
    K [].
tactic (orIR N) (inr T1 H) Vars K :-
    get_named N Vars H,
    K [].

tactic (orE Name1 Name2) (case M F G) Vars K :-
    pi u v \
        K [(Vars, M), ([(u, Name1)|Vars], (F u)), ([(v, Name2)|Vars], (G v))].

% or where sum is hyp
tactic (orE N Name1 Name2) (case H F G) Vars K :-
    get_named N Vars H,
    pi u v \
        K [([(u, Name1)|Vars], (F u)), ([(v, Name2)|Vars], (G v))].    


% ------------------------- %
% ---- TOP/BOT TACTICS ---- %
% ------------------------- %

tactic botE (abort X T) Vars K :-
    K [(Vars, X)].
tactic topI singleton _ K :-
    K []. % ???


% -------------------- %
% ---- HYPOTHESIS ---- %
% -------------------- %

tactic (var N) H Vars K :-
    get_named N Vars H,
    K [].


% Error
tactic Name H Vars K :- 
    print "Error, either" Name "is not a tactic or something was wrong with its args",
    print H,
    print Vars,
    print K.
