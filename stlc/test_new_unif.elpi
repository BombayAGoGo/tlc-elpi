accumulate "../utils".
accumulate new_unif.
accumulate theory.


% Abel & Pientka, 2011
% (x y z\ X x y)        = (x y z\ x (succ y))   -- L_lambda
% (x y z\ X x x y)      = ^                     -- non-linearity
% (x y z\ X (Y x) y)    = ^                     -- meta-meta appl x
% (x y z\ X x (succ y)) = ^                     -- succ y is not a variable
test_i X :-
    test [] 
        (lam (arr nat nat) (x\ lam nat (y\ app (app X x) y)))
        (lam (arr nat nat) (x\ lam nat (y\ app x (succ y)))).
test_j X :-
    test []
        (lam (arr nat nat) (x\ lam nat (y\ app (app (app X x) x) y)))
        (lam (arr nat nat) (x\ lam nat (y\ app x (succ y)))).
ab_c X Y :-
    test []
        (lam (arr nat nat) (x\ lam nat (y\ app (app X (app Y x)) y)))
        (lam (arr nat nat) (x\ lam nat (y\ app x (succ y)))).
test_l X :-
    test []
        (lam (arr nat nat) (x\ lam nat (y\ app (app X x) (succ y))))
        (lam (arr nat nat) (x\ lam nat (y\ app x (succ y)))).

% questo loopa
pd Y :- test [] (lam (arr nat nat) (x\ lam nat (y\ app Y x))) (lam (arr nat nat) (x\ lam nat (y\ app x y))).
pdd X :- test [] (lam nat (x\ lam nat (y\ app X x))) (lam nat (x\ lam nat (y\ y))).

main :- ab_c X Y.

% All these should pass
% NOTE: cosi' e' come dovrebbe essere impostato un problema di unificazione:
%   - assunzioni di tipaggio di costanti
%   - inferenza dei tipi dei due termini,
%   - assunzione di convertibilita' dei due tipi
%   - conversione dei termini
% NOTE: in caso di meta, il tipaggio generera' dei constraint che, qualora
%       violati da qualche assegnamento, lo invalideranno
test_a X :- test [of x nat x, of f (arr nat nat) f] (app X x) (app f x).
test_b X :- test [of x nat x, of f (arr nat nat) f] (app f (app X x)) (app X (app f x)).
test_c X :- test [of f (arr (arr nat nat) (arr nat nat)) f, of g (arr nat nat) g, of n nat n] (app (app f g) n) (app (app X g) n).
test_d X Y :- test [of f (arr nat nat) f] (lam nat (x\ app (app X x) (app Y x))) (lam nat (v\ app f v)). 
test_e X Y :- test [of f (arr nat nat) f] (lam nat (x\ app (app X x) (app Y (succ x)))) (lam nat (v\ app f (succ v))). 
test_f X :- test [of a nat a, of g (arr nat (arr nat nat)) g] (app X a) (app (app g a) a).
test_g X :- test [of w nat w, of u (arr nat nat) u] (lam (arr nat nat) (y\ app y (app X w))) (lam (arr nat nat) (x\ app x (app u w))).
test_h X :- test [of x nat x, of g (arr nat (arr nat nat)) g, of b nat b, of a nat a] (app X x) (app (app g b) a).

test As T T' :- As => (of T A _, of T' B _, conv A B, conv T T').

% test che non passano ma potrebbero
% COMMENTO: Y ha succ x in input, potrebbe usare una qualche funzione (es. pred o -1)
% opportunamente definita per manipolare il suo input e ottenere x
% test_ X Y :- test [of f (arr nat nat) f] (lam nat (x\ app (app X x) (app Y (succ x)))) (lam nat (v\ app f v). 
