accumulate utils.
accumulate stlc/theory.

% tmp start
prove Term :-
    isa PTerm (arr a a) Term,
    refine PTerm [].

% ----------------------- %
% ---- ITP PROCEDURE ---- %
% ----------------------- %

mode (process_input i i i).
% NOTE: this could be used to add new ways
% to handle input, for instance getting
% manual input form the user and so on
process_input (tac Name) X Vars :-
    tac Name (Vars, X) PTerm,
    X = PTerm,
    refine PTerm Vars.

% Core of itp procedure
% IDEA: you want to build a term X of type T
% to do this you have to fill all the holes in
% the term, to do this you use recursion on the
% partial term. Once all meta-vars are filled,
% the whole term will be returned.
mode (refine i i).
refine A B :- print (refine A B), fail.
refine (uvar as X) Vars :- !,
    print_info X Vars,
    read T,
    process_input T X Vars.

refine (app M N) Vars :- !, refine M Vars, refine N Vars.
refine (lam N T F) Vars :- !, pi x\ refine (F x) [(x, N)|Vars].
refine X Vars :- !, name X.

% ----------------- %
% ---- TACTICS ---- %
% ----------------- %

mode (tac i i o).

% Primitive
tac (intro N) (_, _) (lam N T F).
tac app (_, _) (app M N).
tac (var N) (Vars, _) H :-
    get_named N Vars H.

% Non primitive
tac (mapp N) (Vars, X) PTerm :-
    get_named N Vars H,
    get_ctx X (isa H T _, dots H T PTerm).

mode (dots i i o).
dots X T X :- isa X T O. 
dots Lam T PTerm :-
    isa Lam (arr _ _) _,
    dots (app Lam Arg) T PTerm.

% ------------- %
% ---- AUX ---- %
% ------------- %

print_info X Vars :-
    print_constraints,
    print, print Vars "|-" X.

% Given a meta, get what type you should prove it to be
%mode (get_type i o).
%get_type (uvar as X) T :- declare_constraint (get_type X T) [X].

% Given a meta, perform some code under its isa context
% i.e. bring into the tactic [isa x0 t x0, ...].
mode (get_ctx i o).
get_ctx (uvar as X) Body :- declare_constraint (get_ctx X Body) [X].
