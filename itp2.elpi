accumulate stlc/theory.
accumulate utils.

% TODO:
% - pretty print type in print_status

% ------------------- %
% ---- INTERFACE ---- %
% ------------------- %

prove Type ProofTerm OutScript :-
    prove Type [] ProofTerm OutScript.

prove Type InScript ProofTerm OutScript :-
    of X Type ProofTerm,
    itp_loop [goal X Type ProofTerm []] InScript OutScript,
    print "finished" ProofTerm.

% -------------- %
% ---- LOOP ---- %
% -------------- %

% itp_loops args:
% - list of current open goals
% - input tactics list
% - output script list
type itp_loop goal -> list tactic -> list tactic -> o.
mode (itp_loop i i o).
%itp_loop A B C :- print (itp_loop A B C), fail.

itp_loop [] _ _.

% hole - no input
itp_loop [(goal (uvar as Hole) Type RTerm VDecls as Goal) | Goals] [] OutScript :-
    print_status Goal,
    print "constraints at query",
    print_constraints, print,
    prompt_user Tac,
    itp_loop (Goal :: Goals) [Tac] OutScript.

% hole - input
itp_loop [(goal (uvar as Hole) Type RTerm VDecls as Goal) | Goals] [Tac | Tacs] OutScript :-
    tactic Tac Goal NewGoals,
    append NewGoals Goals UpdatedGoals,
    itp_loop UpdatedGoals Tacs OutScript',
    append [Tac] OutScript' OutScript.

tactic (intro N) (goal X Type RTerm VDecls) NewGoals :-
    assign_under X (lam N T F) VDecls,
    print,
    print "constraints after tactic assignment",
    print_constraints, print,
    build_newgoals RTerm VDecls VDecls NewGoals.
    /*
    recover_metas RTerm [F'],
    get_evar_type F' Type_F,
    SubGoals = [goal F Type_F F' (vdecl N T :: VDecls)].
    */

tactic (mapp N) (goal X Type RTerm VDecls) NewGoals :-
    assign_named_under X (app Lam dots) VDecls N Lam,
    build_newgoals RTerm VDecls VDecls NewGoals.

% --------------- %
% ---- UTILS ---- %
% --------------- %

mode (lookdown i i i).
lookdown (uvar K L as X) Y T :- declare_constraint (read-refined X Y T) [X].

constraint isa read-evar read-refined of {
    rule (E1 : Ctx ?- isa (uvar K L1) Ty (uvar O L1' as Y))
        \ (E2 : read-refined (uvar O L2) X T)
        | (/*print "match" L1 L1' L2,*/ L1 = L1', !; print "align fail on" L1 "=" L1')
        <=> (E2 : X = uvar K L2, T = Ty).
}

%get_evar_from_refined Y X :- declare_constraint (read-refined Y X) [Y].

/*
constraint read-refined of isa {
    rule (E1 : Ctx ?- isa (uvar K L1) Ty (uvar O L1' as Y))
        \ (E2 : read-refined (uvar O L2) X)
        | (print "match", L1 = L1')
        <=> (E2 : X = uvar K L2).
}
*/

mode (assign_under i i i).
assign_under X Term [] :- X = Term.
assign_under X Term (vdecl _ _ :: VDecls) :-
    pi x\ assign_under (X x) Term VDecls.

mode (assign_named_under i i i i i).
assign_named_under X Term [] _ _ :- print "assign" Term "to" X, X = Term.
assign_named_under X Term (vdecl Name _ :: VDecls) Name Var :-
    pi x\ (Var = x, print "++++" x Name Var Term, assign_named_under X Term VDecls _ _).
assign_named_under X Term (vdecl Name' _ :: VDecls) Name Var :-
    pi x\ (print "----" Name Var Term, assign_named_under X Term VDecls Name Var).

mode (build_newgoals i i i i).
%build_newgoals A B C D :- print (build_newgoals A B C D), fail.

build_newgoals Term (vdecl N T :: VDecls) NewVDecls NewGoals :-
    pi x\ build_newgoals (Term x) VDecls NewVDecls NewGoals.

build_newgoals (uvar as Y) [] NewVDecls NewGoals :-
    lookdown Y X T,
    NewGoals = [goal X T Y NewVDecls].
build_newgoals (lam N T F) [] NewVDecls NewGoals :-
    append NewVDecls [vdecl N T] L,
    build_newgoals F [] L NewGoals.
build_newgoals (app M N) [] NewVDecls NewGoals :-
    build_newgoals M [] NewVDecls NewGoals',
    build_newgoals N [] NewVDecls NewGoals'',
    append NewGoals' NewGoals'' NewGoals.

print_status (goal PTerm Type _ VDecls) :-
    print,
    print VDecls "|-" PTerm ":" Type.

prompt_user Tac :-
    print "input tactic:", read Tac.
