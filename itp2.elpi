accumulate "commons/typing".
accumulate stlc/lang, stlc/typing, stlc/conv, stlc/pp.
accumulate utils.

% TODO:
% - tattiche multiple (i.e. su piu' goal)
% - tatticali

% ------------------- %
% ---- INTERFACE ---- %
% ------------------- %

prove Type ProofTerm OutScript :-
    prove Type [] ProofTerm OutScript.

prove Type InScript ProofTerm OutScript :-
    of X Type ProofTerm,
    itp_loop [goal X Type ProofTerm []] InScript OutScript.

% -------------- %
% ---- LOOP ---- %
% -------------- %

% itp_loops args:
% - list of current open goals
% - input tactics list
% - output script list
mode (itp_loop i i o).
%itp_loop A B C :- print (itp_loop A B C), fail.

itp_loop [] _ [].

% hole - no input - no choice
itp_loop [Goal] [] OutScript :- !,
    print_goal Goal,
    prompt_user "input tactic" Tac,
    (Tac = backup, !, fail;
    itp_loop [Goal] [Tac] OutScript;
    itp_loop [Goal] [] OutScript).

% hole - no input - choice
itp_loop Goals [] OutScript :-
    print_goals Goals,
    prompt_user "select goal" GNum,
    get_nth GNum Left Goals Right Goal,
    append Left Right Rest,
    prompt_user "input tactic" Tac,
    (Tac = backup, !, fail;
    itp_loop (Goal :: Rest) [Tac] OutScript;
    itp_loop Goals [] OutScript).

% hole - input
itp_loop (Goal :: Goals) (Tac :: Tacs) OutScript :-
    tac_under_ctx Tac [Goal] NewGoals,
    append NewGoals Goals UpdatedGoals,
    itp_loop UpdatedGoals Tacs OutScript',
    append [Tac] OutScript' OutScript.

% ----------------- %
% ---- TACTICS ---- %
% ----------------- %

% tactic name goals fresh_vars new_goals

tactic (intro N) (goal X Type RTerm VDecls) FVars NewGoals :-
    X = lam N T F,
    build_newgoals RTerm VDecls NewGoals.

tactic (mapp N) (goal X Type RTerm VDecls) FVars NewGoals :-
    get_named N FVars Lam,
    X = app Lam dots,
    build_newgoals RTerm VDecls NewGoals.

% ------------------- %
% ---- TACTICALS ---- %
% ------------------- %

tactic idtac Goal _ Goal.
tactic (then T1 T2) Goal FVars NewGoals :-
    tactic T1 Goal FVars MidGoals, tac_under_ctx T2 MidGoals NewGoals.   

tactic (orelse T1 _T2) Goal FVars NewGoals :- tactic T1 Goal FVars NewGoals.
tactic (orelse _T1 T2) Goal FVars NewGoals :- tactic T2 Goal FVars NewGoals.
%tactic (orelse T1 T2) Goal FVars NewGoals :-
%    tactic T1 Goal FVars NewGoals; tactic T2 Goal FVars NewGoals.

tactic (orelse! T1 _T2) Goal FVars NewGoals :- tactic T1 Goal FVars NewGoals, !.
tactic (orelse! _T1 T2) Goal FVars NewGoals :- tactic T2 Goal FVars NewGoals.
%tactic (orelse! T1 T2) Goal FVars NewGoals :-
%    tactic T1 Goal FVars NewGoals, !; tactic T2 Goal FVars NewGoals.

tactic (try T) Goal FVars NewGoals :- tactic (orelse T idtac) Goal FVars NewGoals.
tactic (solve T) Goal FVars NewGoals :- tactic T Goal FVars NewGoals, NewGoals = [].
tactic (repeat T) Goal FVars NewGoals :- tactic (then T (try (repeat T))) Goal FVars NewGoals.

tactic (do 0 T) Goal _ Goal.
tactic (do N T) Goal FVars NewGoals :-
    M is N - 1, tactic (then T (do M T)) Goal FVars NewGoals.

tactic (first []) Goal _ Goal.
tactic (first (Tac :: Tacs)) Goal FVars NewGoals :- tactic (orelse Tac (first Tacs)) Goal FVars NewGoals.

% --------------- %
% ---- UTILS ---- %
% --------------- %

% apply tac to many goals
mode (tac_under_ctx i i o).
%tac_under_ctx A B C :- print (tac_under_ctx A B C), fail.
tac_under_ctx _ [] [].
tac_under_ctx Tac ((goal X T Y D as Goal) :: Goals) NG :-
    tac_under_ctx_base Tac Goal D [] NG',
    tac_under_ctx Tac Goals NGS,
    append NG' NGS NG.

% apply tac to one goal
mode (tac_under_ctx_base i i i i o).
%tac_under_ctx_base A B C D E :- print (tac_under_ctx_base A B C D E), fail.
tac_under_ctx_base Tac (goal X T Y D) (vdecl N _ :: VDecls) FVars NG :-
    pi x\ tac_under_ctx_base Tac (goal (X x) T (Y x) D) VDecls ((x, N) :: FVars) NG.

tac_under_ctx_base Tac (goal X T Y D as G) [] FVars NewGoals :-
    tactic Tac G FVars NewGoals.

mode (build_newgoals i i o).
%build_newgoals A B C :- print (build_newgoals A B C), fail.

build_newgoals (uvar K L as Y) VDecls NewGoals :-
    lookdown Y X T,
    NewGoals = [goal X T K VDecls].
build_newgoals (lam N T F) VDecls NewGoals :-
    append VDecls [vdecl N T] L,
    pi x\ build_newgoals (F x) L NewGoals.
build_newgoals (app M N) VDecls NewGoals :-
    build_newgoals M VDecls NewGoals',
    build_newgoals N VDecls NewGoals'',
    append NewGoals' NewGoals'' NewGoals.
build_newgoals FVar _ [] :- name FVar.

mode (get_nth i o i o o).
%get_nth A B C D E :- print (get_nth A B C D E), fail.
get_nth 1 [] [X|XS] XS X.
get_nth N L [X|XS] R Res :-
    M is N - 1,
    get_nth M L' XS R Res,
    append L' [X] L.     

mode (lookdown i i i).
lookdown (uvar _ _ as X) Y T :- declare_constraint (read-refined X Y T) [X].

constraint isa read-evar read-refined of {
    rule (E1 : Ctx ?- isa (uvar K L1) Ty (uvar O L1' as Y))
        \ (E2 : read-refined (uvar O L2) X T)
        | (/* print "match" L1 L1' L2, */ L1 = L1', !; print "align fail on" L1 "=" L1', halt)
        <=> (E2 : X = uvar K [], T = Ty).
}

% ------------- %
% ---- I/O ---- %
% ------------- %

print_goals (Goal :: Goals) :-
    length (Goal :: Goals) N,
    term_to_string N SN,
    P is "you got "^ SN ^ " open goals",
    print,
    print P,
    print_goal_aux 1 N (Goal :: Goals).

print_goal Goal :-
    print,
    print "you got 1 open goal",
    print_goal_aux 1 1 [Goal].

print_goal_aux _ 0 [].
print_goal_aux Current Length (goal PTerm Type _ VDecls :: Goals) :-
    pp Type TypePP,
    vdecls_to_string VDecls VDString,
    term_to_string Current SCurrent,
    term_to_string PTerm SPTerm,
    S is SCurrent ^ ") [" ^ VDString ^ "] |- " ^ SPTerm ^ ": " ^ TypePP,
    print S,
    Length' is Length - 1,
    Current' is Current + 1,
    print_goal_aux Current' Length' Goals.

prompt_user Msg Input :-
    print Msg, read Input, print.

vdecls_to_string [] "".
vdecls_to_string (vdecl N T :: VDecls) S :-
    vdecls_to_string VDecls S',
    pp T TPP,
    term_to_string N SN,
    (S' is "", S is "(" ^ SN ^ ": " ^ TPP ^ ")", !;
    S is "(" ^ SN ^ ": " ^ TPP ^ "), " ^ S').
