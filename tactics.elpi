accumulate typing.

% return a lambda abstraction, prove (F x) 
tactic intro (lam Z F) Vars K :-
    pi x \ K [([x|Vars], (F x))].

% one step hypothetical app aka I don't have an immediate function
% ex: (A => B => C) => ((A & B) => C)
%     we'll need to do B => C, C |- C
tactic app (app H G) Vars K :-
    K [(Vars, G), (Vars, H)].

% one step concrete app aka I have a function that already proves the A => B part
tactic (app N) (app H G) Vars K :- 
    nth_element N Vars H, 
    K [(Vars, G)]. 

% and tactics
tactic andEL (fst X) Vars K :-
    K [(Vars, X)].
tactic andER (snd X) Vars K :-
    K [(Vars, X)].
tactic andI (pair A B) Vars K :-
    K [(Vars, A), (Vars, B)].

% or tactics
tactic orIL (inl T2 X) Vars K :-
    K [(Vars, X)].
tactic orIR (inr T1 X) Vars K :-
    K [(Vars, X)].
tactic orE (case M F G) Vars K :-
    pi u \ 
        pi v \
            K [(Vars, M), ([u|Vars], (F u)), ([v|Vars], (G v))].

% not 
% [A] ... \bot / -A
%tactic notI (not T F) Vars K :-
%    pi x \ K [([x|Vars]), (F x)].
% A -A / C
%tactic (notE N In) In Vars K :-
%    nth_element N Vars A,
%    K [(Vars, A), (Vars, (not T A))].
% \bot / C
%tactic botE (abort X T) Vars K :-
%    K [(Vars, X)].
% / \top
%tactic topI singl Vars K.

% hypothesis use
tactic (var N) H Vars K :- 
    nth_element N Vars H, 
    K [].

