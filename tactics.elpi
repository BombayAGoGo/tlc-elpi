accumulate terms.
accumulate typing.


% return a lambda abstraction, prove (F x)
tactic intro (lam Z F) Vars K :-
    pi x \ K [([x|Vars], (F x))].

% one step hypothetical app aka I don't have an immediate function
% ex: (A => B => C) => ((A & B) => C)
%     we'll need to do B => C, C |- C
tactic app (app H G) Vars K :-
    K [(Vars, G), (Vars, H)].

% one step concrete app aka I have a function that already proves the A => B part
tactic (app N) (app H G) Vars K :-
    nth_element N Vars H,
    K [(Vars, G)].

% and tactics
tactic andEL (fst X) Vars K :-
    K [(Vars, X)].
tactic andER (snd X) Vars K :-
    K [(Vars, X)].
% and elimination but with hypothesis use
tactic (andER N) (snd H) Vars K :-
    nth_element N Vars H,
    K [].
tactic (andEL N) (fst H) Vars K :-
    nth_element N Vars H,
    K [].

tactic andI (pair A B) Vars K :-
    K [(Vars, A), (Vars, B)].
% and intro with hyp use
tactic (andI N M) (pair H I) Vars K :-
    nth_element N Vars H,
    nth_element M Vars I,
    K [].


% or tactics
tactic orIL (inl T2 X) Vars K :-
    K [(Vars, X)].
tactic orIR (inr T1 X) Vars K :-
    K [(Vars, X)].
tactic orE (case M F G) Vars K :-
    pi u \
        pi v \
            K [(Vars, M), ([u|Vars], (F u)), ([v|Vars], (G v))].

% not
tactic notI (not T F) Vars K :-
    pi x \ K [([x|Vars]), (F x)].
tactic notE (notApp C M N) Vars K :-
    print C, print M, print N, print K,
    K [(Vars, M), (Vars, N)].
% \bot / C
%tactic botE (abort X T) Vars K :-
%    K [(Vars, X)].
% / \top
%tactic topI singl Vars K.

% hypothesis use
tactic (var N) H Vars K :-
    nth_element N Vars H,
    print H, print K,
    K [].

tactic Name H Vars K :- 
    print "Error, either" Name "is not a tactic or something was wrong with its args",
    print H,
    print Vars,
    print K.
